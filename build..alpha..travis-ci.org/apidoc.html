<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/rethinkdb/horizon#readme"

    >horizon (v2.0.0)</a>
</h1>
<h4>An open-source developer platform for building realtime, scalable web apps.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon">module horizon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.start_rdb_server">
            function <span class="apidocSignatureSpan">horizon.</span>start_rdb_server
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>create_cert</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>init</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>interrupt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>make_token</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>migrate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>schema</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>serve</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.config">module horizon.config</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.config.default_options">
            function <span class="apidocSignatureSpan">horizon.config.</span>default_options
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.config.merge_options">
            function <span class="apidocSignatureSpan">horizon.config.</span>merge_options
            <span class="apidocSignatureSpan">(old_options, new_options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.config.parse_connect">
            function <span class="apidocSignatureSpan">horizon.config.</span>parse_connect
            <span class="apidocSignatureSpan">(connect, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.config.read_from_config_file">
            function <span class="apidocSignatureSpan">horizon.config.</span>read_from_config_file
            <span class="apidocSignatureSpan">(project_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.config.read_from_env">
            function <span class="apidocSignatureSpan">horizon.config.</span>read_from_env
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.config.read_from_flags">
            function <span class="apidocSignatureSpan">horizon.config.</span>read_from_flags
            <span class="apidocSignatureSpan">(parsed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.config.read_from_secrets_file">
            function <span class="apidocSignatureSpan">horizon.config.</span>read_from_secrets_file
            <span class="apidocSignatureSpan">(projectPath)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.config.</span>default_config_file</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.config.</span>default_secrets_file</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.create_cert">module horizon.create_cert</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.create_cert.run">
            function <span class="apidocSignatureSpan">horizon.create_cert.</span>run
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.create_cert.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.init">module horizon.init</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.init.run">
            function <span class="apidocSignatureSpan">horizon.init.</span>run
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.init.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.interrupt">module horizon.interrupt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.interrupt.interrupt">
            function <span class="apidocSignatureSpan">horizon.</span>interrupt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.interrupt.on_interrupt">
            function <span class="apidocSignatureSpan">horizon.interrupt.</span>on_interrupt
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.make_token">module horizon.make_token</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.make_token.run">
            function <span class="apidocSignatureSpan">horizon.make_token.</span>run
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.make_token.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.migrate">module horizon.migrate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.migrate.run">
            function <span class="apidocSignatureSpan">horizon.migrate.</span>run
            <span class="apidocSignatureSpan">(cmdArgs)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.migrate.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.schema">module horizon.schema</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.schema.parse_schema">
            function <span class="apidocSignatureSpan">horizon.schema.</span>parse_schema
            <span class="apidocSignatureSpan">(schema_toml)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.schema.processApplyConfig">
            function <span class="apidocSignatureSpan">horizon.schema.</span>processApplyConfig
            <span class="apidocSignatureSpan">(parsed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.schema.run">
            function <span class="apidocSignatureSpan">horizon.schema.</span>run
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.schema.runApplyCommand">
            function <span class="apidocSignatureSpan">horizon.schema.</span>runApplyCommand
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.schema.runSaveCommand">
            function <span class="apidocSignatureSpan">horizon.schema.</span>runSaveCommand
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.schema.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.serve">module horizon.serve</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.serve.parseArguments">
            function <span class="apidocSignatureSpan">horizon.serve.</span>parseArguments
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.serve.processConfig">
            function <span class="apidocSignatureSpan">horizon.serve.</span>processConfig
            <span class="apidocSignatureSpan">(parsed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.serve.run">
            function <span class="apidocSignatureSpan">horizon.serve.</span>run
            <span class="apidocSignatureSpan">(args, interruptor)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.serve.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.start_rdb_server">module horizon.start_rdb_server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.start_rdb_server.start_rdb_server">
            function <span class="apidocSignatureSpan">horizon.</span>start_rdb_server
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.start_rdb_server.r">
            function <span class="apidocSignatureSpan">horizon.start_rdb_server.</span>r
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.version">module horizon.version</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.version.run">
            function <span class="apidocSignatureSpan">horizon.version.</span>run
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.version.</span>description</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon" id="apidoc.module.horizon">module horizon</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.start_rdb_server" id="apidoc.element.horizon.start_rdb_server">
        function <span class="apidocSignatureSpan">horizon.</span>start_rdb_server
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(options) =&#x3e; new RethinkdbServer(options || { }).ready()</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.config" id="apidoc.module.horizon.config">module horizon.config</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.config.default_options" id="apidoc.element.horizon.config.default_options">
        function <span class="apidocSignatureSpan">horizon.config.</span>default_options
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&#x3e; ({
  config: null,
  debug: false,
  // Default to current directory for path
  project_path: &#x27;.&#x27;,
  // Default to current directory name for project name
  project_name: null,

  bind: [ &#x27;localhost&#x27; ],
  port: 8181,

  start_rethinkdb: false,
  serve_static: null,
  open: false,

  secure: true,
  permissions: true,
  key_file: &#x27;./horizon-key.pem&#x27;,
  cert_file: &#x27;./horizon-cert.pem&#x27;,
  schema_file: null,

  auto_create_collection: false,
  auto_create_index: false,

  rdb_host: null,
  rdb_port: null,
  rdb_user: null,
  rdb_password: null,
  rdb_timeout: null,

  token_secret: null,
  allow_anonymous: false,
  allow_unauthenticated: false,
  auth_redirect: &#x27;/&#x27;,
  access_control_allow_origin: &#x27;&#x27;,

  auth: { },
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...

return parser.parseArgs(args);
};

const processConfig = (parsed) =&#x3e; {
let options;

options = config.<span class="apidocCodeKeywordSpan">default_options</span>();

options = config.merge_options(
  options, config.read_from_config_file(parsed.project_path));
options = config.merge_options(
  options, config.read_from_secrets_file(parsed.project_path));
options = config.merge_options(options, config.read_from_env());
options = config.merge_options(options, config.read_from_flags(parsed));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.config.merge_options" id="apidoc.element.horizon.config.merge_options">
        function <span class="apidocSignatureSpan">horizon.config.</span>merge_options
        <span class="apidocSignatureSpan">(old_options, new_options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(old_options, new_options) =&#x3e; {
  // Disable start_rethinkdb if it was enabled by dev mode but we already have a host
  if (new_options._start_rethinkdb_implicit) {
    if (old_options.rdb_host) {
      delete new_options.start_rethinkdb;
    }
  } else if (new_options.start_rethinkdb &#x26;&#x26; new_options.rdb_host) {
    throw new Error(&#x27;Cannot provide both --start-rethinkdb and --connect.&#x27;);
  }

  for (const key in new_options) {
    if (key === &#x27;rdb_host&#x27;) {
      old_options.start_rethinkdb = false;
    }

    if (key === &#x27;auth&#x27;) {
      for (const provider in new_options.auth) {
        old_options.auth[provider] = old_options.auth[provider] || { };
        for (const field in new_options.auth[provider]) {
          old_options.auth[provider][field] = new_options.auth[provider][field];
        }
      }
    } else {
      old_options[key] = new_options[key];
    }
  }

  return old_options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

const processConfig = (parsed) =&#x3e; {
let options;

options = config.default_options();

options = config.<span class="apidocCodeKeywordSpan">merge_options</span>(
  options, config.read_from_config_file(parsed.project_path));
options = config.merge_options(
  options, config.read_from_secrets_file(parsed.project_path));
options = config.merge_options(options, config.read_from_env());
options = config.merge_options(options, config.read_from_flags(parsed));

if (options.project_name === null) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.config.parse_connect" id="apidoc.element.horizon.config.parse_connect">
        function <span class="apidocSignatureSpan">horizon.config.</span>parse_connect
        <span class="apidocSignatureSpan">(connect, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(connect, config) =&#x3e; {
  // support rethinkdb:// style connection uri strings
  // expects rethinkdb://host:port` at a minimum but can optionally take a user:pass and db
  // e.g. rethinkdb://user:pass@host:port/db
  const rdb_uri = url.parse(connect);
  if (rdb_uri.protocol === &#x27;rethinkdb:&#x27;) {
    if (rdb_uri.hostname) {
      config.rdb_host = rdb_uri.hostname;
      config.rdb_port = rdb_uri.port || default_rdb_port;

      // check for user/pass
      if (rdb_uri.auth) {
        const user_pass = rdb_uri.auth.split(&#x27;:&#x27;);
        config.rdb_user = user_pass[0];
        config.rdb_password = user_pass[1];
      }

      // set the project name based on the db
      if (rdb_uri.path &#x26;&#x26; rdb_uri.path.replace(&#x27;/&#x27;, &#x27;&#x27;) !== &#x27;&#x27;) {
        config.project_name = rdb_uri.path.replace(&#x27;/&#x27;, &#x27;&#x27;);
      }
    } else {
      throw new Error(`Expected --connect rethinkdb://HOST, but found &#x22;${connect}&#x22;.`);
    }
  } else {
    // support legacy HOST:PORT connection strings
    const host_port = connect.split(&#x27;:&#x27;);
    if (host_port.length === 1) {
      config.rdb_host = host_port[0];
      config.rdb_port = default_rdb_port;
    } else if (host_port.length === 2) {
      config.rdb_host = host_port[0];
      config.rdb_port = parseInt(host_port[1]);
      if (isNaN(config.rdb_port) || config.rdb_port &#x3c; 0 || config.rdb_port &#x3e; 65535) {
        throw new Error(`Invalid port: &#x22;${host_port[1]}&#x22;.`);
      }
    } else {
      throw new Error(`Expected --connect HOST:PORT, but found &#x22;${connect}&#x22;.`);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    rdb_password: parsed.rdb_password || confOptions.rdb_password || &#x27;&#x27;,
    start_rethinkdb: parse_yes_no_option(parsed.start_rethinkdb),
    skip_backup: parse_yes_no_option(parsed.skip_backup),
    nonportable_backup: parse_yes_no_option(parsed.nonportable_backup),
  };
  // sets rdb_host and rdb_port from connect if necessary
  if (parsed.connect) {
    config.<span class="apidocCodeKeywordSpan">parse_connect</span>(parsed.connect, options);
  }

  if (options.project_name == null) {
    throw new NiceError(&#x27;No project_name given&#x27;, {
      description: `\
The project_name is needed to migrate from the v1.x format the v.2.0 format. \
It wasn&#x27;t passed on the command line or found in your config.`,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.config.read_from_config_file" id="apidoc.element.horizon.config.read_from_config_file">
        function <span class="apidocSignatureSpan">horizon.config.</span>read_from_config_file
        <span class="apidocSignatureSpan">(project_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(project_path) =&#x3e; {
  const config = { auth: { } };

  let fileData, configFilename, fileConfig;

  if (project_path) {
    configFilename = `${project_path}/${default_config_file}`;
  } else {
    configFilename = default_config_file;
  }

  try {
    fileData = fs.readFileSync(configFilename);
  } catch (err) {
    return config;
  }

  try {
    fileConfig = toml.parse(fileData);
  } catch (e) {
    if (e.name === &#x27;SyntaxError&#x27;) {
      throw new NiceError(
        `There was a syntax error when parsing ${configFilename}`, {
          description: `Something was wrong with the format of \
${configFilename}, causing it not be a valid TOML file.`,
          src: {
            filename: configFilename,
            contents: fileData,
            line: e.line,
            column: e.column,
          },
          suggestions: [
            &#x27;Check that all strings values have quotes around them&#x27;,
            &#x27;Check that key/val pairs use equals and not colons&#x27;,
            &#x27;See https://github.com/toml-lang/toml#user-content-spec&#x27;,
          ],
        });
    } else {
      throw e;
    }
  }
  for (const field in fileConfig) {
    if (field === &#x27;connect&#x27;) {
      parse_connect(fileConfig.connect, config);
    } else if (yes_no_options.indexOf(field) !== -1) {
      config[field] = parse_yes_no_option(fileConfig[field], field);
    } else if (default_options[field] !== undefined) {
      config[field] = fileConfig[field];
    } else {
      throw new Error(`Unknown config parameter: &#x22;${field}&#x22;.`);
    }
  }
  return config;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

const processConfig = (parsed) =&#x3e; {
let options;

options = config.default_options();

options = config.merge_options(
  options, config.<span class="apidocCodeKeywordSpan">read_from_config_file</span>(parsed.project_path));
options = config.merge_options(
  options, config.read_from_secrets_file(parsed.project_path));
options = config.merge_options(options, config.read_from_env());
options = config.merge_options(options, config.read_from_flags(parsed));

if (options.project_name === null) {
  options.project_name = path.basename(path.resolve(options.project_path));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.config.read_from_env" id="apidoc.element.horizon.config.read_from_env">
        function <span class="apidocSignatureSpan">horizon.config.</span>read_from_env
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&#x3e; {
  const config = { auth: { } };
  for (const env_var in process.env) {
    const matches = env_regex.exec(env_var);
    if (matches &#x26;&#x26; matches[1]) {
      const destVarName = matches[1].toLowerCase();
      const varPath = destVarName.split(&#x27;_&#x27;);
      const value = process.env[env_var];

      if (destVarName === &#x27;connect&#x27;) {
        parse_connect(value, config);
      } else if (destVarName === &#x27;bind&#x27;) {
        config[destVarName] = value.split(&#x27;,&#x27;);
      } else if (varPath[0] === &#x27;auth&#x27;) {
        if (varPath.length !== 3) {
          console.log(`Ignoring malformed Horizon environment variable: &#x22;${env_var}&#x22;, ` +
                      &#x27;should be HZ_AUTH_{PROVIDER}_{OPTION}.&#x27;);
        } else {
          config.auth[varPath[1]] = config.auth[varPath[1]] || { };
          config.auth[varPath[1]][varPath[2]] = value;
        }
      } else if (yes_no_options.indexOf(destVarName) !== -1) {
        config[destVarName] = parse_yes_no_option(value, destVarName);
      } else if (default_options[destVarName] !== undefined) {
        config[destVarName] = value;
      }
    }
  }

  return config;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = config.default_options();

options = config.merge_options(
  options, config.read_from_config_file(parsed.project_path));
options = config.merge_options(
  options, config.read_from_secrets_file(parsed.project_path));
options = config.merge_options(options, config.<span class="apidocCodeKeywordSpan">read_from_env</span>());
options = config.merge_options(options, config.read_from_flags(parsed));

if (options.project_name === null) {
  options.project_name = path.basename(path.resolve(options.project_path));
}

return Object.assign(options, { user: parsed.user });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.config.read_from_flags" id="apidoc.element.horizon.config.read_from_flags">
        function <span class="apidocSignatureSpan">horizon.config.</span>read_from_flags
        <span class="apidocSignatureSpan">(parsed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(parsed) =&#x3e; {
  const config = { auth: { } };

  // Dev mode
  if (parsed.dev) {
    config.access_control_allow_origin = &#x27;*&#x27;;
    config.allow_unauthenticated = true;
    config.allow_anonymous = true;
    config.secure = false;
    config.permissions = false;
    config.start_rethinkdb = true;
    config.auto_create_collection = true;
    config.auto_create_index = true;
    config.serve_static = &#x27;dist&#x27;;
    config._dev_flag_used = true;

    if (parsed.start_rethinkdb === null || parsed.start_rethinkdb === undefined) {
      config._start_rethinkdb_implicit = true;
    }
  }

  for (const key in parsed) {
    if (key === &#x27;auth&#x27; &#x26;&#x26; parsed.auth != null) {
      // Auth options
      parsed.auth.forEach((auth_options) =&#x3e; {
        const params = auth_options.split(&#x27;,&#x27;);
        if (params.length !== 3) {
          throw new Error(`Expected --auth PROVIDER,ID,SECRET, but found &#x22;${auth_options}&#x22;`);
        }
        config.auth[params[0]] = { id: params[1], secret: params[2] };
      });
    } else if (key === &#x27;connect&#x27; &#x26;&#x26; parsed.connect != null) {
      // Normalize RethinkDB connection options
      parse_connect(parsed.connect, config);
    } else if (yes_no_options.indexOf(key) !== -1 &#x26;&#x26; parsed[key] != null) {
      // Simple &#x27;yes&#x27; or &#x27;no&#x27; (or &#x27;true&#x27; or &#x27;false&#x27;) flags
      config[key] = parse_yes_no_option(parsed[key], key);
    } else if (parsed[key] != null) {
      config[key] = parsed[key];
    }
  }

  return config;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  options = config.default_options();

  options = config.merge_options(
    options, config.read_from_config_file(parsed.project_path));
  options = config.merge_options(
    options, config.read_from_secrets_file(parsed.project_path));
  options = config.merge_options(options, config.read_from_env());
  options = config.merge_options(options, config.<span class="apidocCodeKeywordSpan">read_from_flags</span>(parsed));

  if (options.project_name === null) {
    options.project_name = path.basename(path.resolve(options.project_path));
  }

  return Object.assign(options, { user: parsed.user });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.config.read_from_secrets_file" id="apidoc.element.horizon.config.read_from_secrets_file">
        function <span class="apidocSignatureSpan">horizon.config.</span>read_from_secrets_file
        <span class="apidocSignatureSpan">(projectPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(projectPath) =&#x3e; {
  const config = { auth: { } };

  let fileData, secretsFilename;

  if (projectPath) {
    secretsFilename = `${projectPath}/${default_secrets_file}`;
  } else {
    secretsFilename = default_secrets_file;
  }

  try {
    fileData = fs.readFileSync(secretsFilename);
  } catch (err) {
    return config;
  }

  const fileConfig = toml.parse(fileData);
  for (const field in fileConfig) {
    if (field === &#x27;connect&#x27;) {
      parse_connect(fileConfig.connect, config);
    } else if (yes_no_options.indexOf(field) !== -1) {
      config[field] = parse_yes_no_option(fileConfig[field], field);
    } else if (default_options[field] !== undefined) {
      config[field] = fileConfig[field];
    } else {
      throw new Error(`Unknown config parameter: &#x22;${field}&#x22;.`);
    }
  }

  return config;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
let options;

options = config.default_options();

options = config.merge_options(
  options, config.read_from_config_file(parsed.project_path));
options = config.merge_options(
  options, config.<span class="apidocCodeKeywordSpan">read_from_secrets_file</span>(parsed.project_path));
options = config.merge_options(options, config.read_from_env());
options = config.merge_options(options, config.read_from_flags(parsed));

if (options.project_name === null) {
  options.project_name = path.basename(path.resolve(options.project_path));
}
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.create_cert" id="apidoc.module.horizon.create_cert">module horizon.create_cert</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.create_cert.run" id="apidoc.element.horizon.create_cert.run">
        function <span class="apidocSignatureSpan">horizon.create_cert.</span>run
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&#x3e; {
  if (args.length) {
    throw new Error(&#x27;create-cert takes no arguments&#x27;);
  }

  // TODO: user configuration?
  const settings = {
    binaryName: &#x27;openssl&#x27;,
    keyOutName: &#x27;horizon-key.pem&#x27;,
    certOutName: &#x27;horizon-cert.pem&#x27;,
    algo: &#x27;rsa&#x27;,
    bits: &#x27;2048&#x27;,
    days: &#x27;365&#x27;,
  };

  // generate the arguments to the command
  const binArgs = [ &#x27;req&#x27;, &#x27;-x509&#x27;, &#x27;-nodes&#x27;, &#x27;-batch&#x27;,
    &#x27;-newkey&#x27;, `${settings.algo}:${settings.bits}`,
    &#x27;-keyout&#x27;, settings.keyOutName,
    &#x27;-out&#x27;, settings.certOutName,
    &#x27;-days&#x27;, settings.days,
  ];

  return new Promise((resolve, reject) =&#x3e; {
    hasbin(settings.binaryName, (hasOpenSSL) =&#x3e; {
      // show the invocation that&#x27;s about to be run
      console.log(`&#x3e; ${settings.binaryName} ${binArgs.join(&#x27; &#x27;)}`);

      // if we don&#x27;t have openssl, bail
      if (!hasOpenSSL) {
        reject(new Error(`Missing ${settings.binaryName}. Make sure it is on the path.`));
      }

      // otherwise start openssl
      const sslProc = spawn(settings.binaryName, binArgs);

      // pipe output appropriately
      sslProc.stdout.pipe(process.stdout, { end: false });
      sslProc.stderr.pipe(process.stderr, { end: false });

      // say nice things to the user when it&#x27;s done
      sslProc.on(&#x27;error&#x27;, reject);
      sslProc.on(&#x27;close&#x27;, (code) =&#x3e; {
        if (code) {
          reject(new Error(`OpenSSL failed with code ${code}.`));
        } else {
          console.log(&#x27;Everything seems to be fine. &#x27; +
                      &#x27;Remember to add your shiny new certificates to your Horizon config!&#x27;);
          resolve();
        }
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&#x3e; {
    white(&#x27;Validating current schema version&#x27;);
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&#x3e; checkForHzTables)
      .do(() =&#x3e; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&#x3e; green(&#x27; └── Pre-2.0 schema found&#x27;))
      .catch((e) =&#x3e; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don&#x27;t have a Horizon app in this database, or if \
you&#x27;ve already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.init" id="apidoc.module.horizon.init">module horizon.init</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.init.run" id="apidoc.element.horizon.init.run">
        function <span class="apidocSignatureSpan">horizon.init.</span>run
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&#x3e;
  Promise.resolve(args)
.then(parseArguments)
.then((parsed) =&#x3e; {
  const check = checkProjectName(
    parsed.projectName,
    process.cwd(),
    fs.readdirSync(&#x27;.&#x27;)
  );
  const projectName = check.projectName;
  const dirName = check.dirName;
  const chdirTo = check.chdirTo;
  const createDir = check.createDir;
  maybeMakeDir(createDir, dirName);
  maybeChdir(chdirTo);

  // Before we create things, check if the directory is empty
  const dirWasPopulated = fs.readdirSync(process.cwd()).length !== 0;
  populateDir(projectName, dirWasPopulated, chdirTo, dirName);
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&#x3e; {
    white(&#x27;Validating current schema version&#x27;);
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&#x3e; checkForHzTables)
      .do(() =&#x3e; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&#x3e; green(&#x27; └── Pre-2.0 schema found&#x27;))
      .catch((e) =&#x3e; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don&#x27;t have a Horizon app in this database, or if \
you&#x27;ve already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.interrupt" id="apidoc.module.horizon.interrupt">module horizon.interrupt</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.interrupt.interrupt" id="apidoc.element.horizon.interrupt.interrupt">
        function <span class="apidocSignatureSpan">horizon.</span>interrupt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&#x3e; {
  process.removeAllListeners(&#x27;SIGTERM&#x27;);
  process.removeAllListeners(&#x27;SIGINT&#x27;);
  process.on(&#x27;SIGTERM&#x27;, () =&#x3e; process.exit(1));
  process.on(&#x27;SIGINT&#x27;, () =&#x3e; process.exit(1));

  return run_handlers();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.interrupt.on_interrupt" id="apidoc.element.horizon.interrupt.on_interrupt">
        function <span class="apidocSignatureSpan">horizon.interrupt.</span>on_interrupt
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(cb) =&#x3e; {
  handlers.push(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const start_rdb_server = require(&#x27;./utils/start_rdb_server&#x27;);
const NiceError = require(&#x27;./utils/nice_error.js&#x27;);

const VERSION_2_0 = [ 2, 0, 0 ];

function run(cmdArgs) {
const options = processConfig(cmdArgs);
interrupt.<span class="apidocCodeKeywordSpan">on_interrupt</span>(() =&#x3e; teardown());
return Promise.resolve().bind({ options })
  .then(setup)
  .then(validateMigration)
  .then(makeBackup)
  .then(renameUserTables)
  .then(moveInternalTables)
  .then(renameIndices)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.make_token" id="apidoc.module.horizon.make_token">module horizon.make_token</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.make_token.run" id="apidoc.element.horizon.make_token.run">
        function <span class="apidocSignatureSpan">horizon.make_token.</span>run
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&#x3e; Promise.resolve().then(() =&#x3e; {
  const options = processConfig(parseArguments(args));

  if (options.token_secret === null) {
    throw new Error(&#x27;No token secret specified, unable to sign the token.&#x27;);
  }
  const token = jwt.sign(
    { id: options.user, provider: null },
    new Buffer(options.token_secret, &#x27;base64&#x27;),
    { expiresIn: &#x27;1d&#x27;, algorithm: &#x27;HS512&#x27; }
  );
  console.log(`${token}`);
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&#x3e; {
    white(&#x27;Validating current schema version&#x27;);
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&#x3e; checkForHzTables)
      .do(() =&#x3e; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&#x3e; green(&#x27; └── Pre-2.0 schema found&#x27;))
      .catch((e) =&#x3e; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don&#x27;t have a Horizon app in this database, or if \
you&#x27;ve already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.migrate" id="apidoc.module.horizon.migrate">module horizon.migrate</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.migrate.run" id="apidoc.element.horizon.migrate.run">
        function <span class="apidocSignatureSpan">horizon.migrate.</span>run
        <span class="apidocSignatureSpan">(cmdArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function run(cmdArgs) {
  const options = processConfig(cmdArgs);
  interrupt.on_interrupt(() =&#x3e; teardown());
  return Promise.resolve().bind({ options })
    .then(setup)
    .then(validateMigration)
    .then(makeBackup)
    .then(renameUserTables)
    .then(moveInternalTables)
    .then(renameIndices)
    .then(rewriteHzCollectionDocs)
    .then(exportNewSchema)
    .finally(teardown);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&#x3e; {
    white(&#x27;Validating current schema version&#x27;);
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&#x3e; checkForHzTables)
      .do(() =&#x3e; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&#x3e; green(&#x27; └── Pre-2.0 schema found&#x27;))
      .catch((e) =&#x3e; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don&#x27;t have a Horizon app in this database, or if \
you&#x27;ve already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.schema" id="apidoc.module.horizon.schema">module horizon.schema</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.schema.parse_schema" id="apidoc.element.horizon.schema.parse_schema">
        function <span class="apidocSignatureSpan">horizon.schema.</span>parse_schema
        <span class="apidocSignatureSpan">(schema_toml)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(schema_toml) =&#x3e; {
  const parsed = Joi.validate(toml.parse(schema_toml), schema_schema);
  const schema = parsed.value;

  if (parsed.error) {
    throw parsed.error;
  }

  const collections = [ ];
  for (const name in schema.collections) {
    collections.push({
      id: name,
      indexes: schema.collections[name].indexes.map((index) =&#x3e; {
        if (typeof index === &#x27;string&#x27;) {
          return { fields: v1_0_name_to_fields(index), multi: false, geo: false };
        } else {
          return { fields: index.fields, multi: false, geo: false };
        }
      }),
    });
  }

  // Make sure the &#x27;users&#x27; collection is present, as some things depend on
  // its existence.
  if (!schema.collections || !schema.collections.users) {
    collections.push({ id: &#x27;users&#x27;, indexes: [ ] });
  }

  const groups = [ ];
  for (const name in schema.groups) {
    groups.push(Object.assign({ id: name }, schema.groups[name]));
  }

  return { groups, collections };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.schema.processApplyConfig" id="apidoc.element.horizon.schema.processApplyConfig">
        function <span class="apidocSignatureSpan">horizon.schema.</span>processApplyConfig
        <span class="apidocSignatureSpan">(parsed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(parsed) =&#x3e; {
  let options, in_file;

  options = config.default_options();
  options = config.merge_options(options,
    config.read_from_config_file(parsed.project_path));
  options = config.merge_options(options, config.read_from_env());
  options = config.merge_options(options, config.read_from_flags(parsed));

  if (parsed.schema_file === &#x27;-&#x27;) {
    in_file = process.stdin;
  } else {
    in_file = fs.createReadStream(parsed.schema_file, { flags: &#x27;r&#x27; });
  }

  if (options.project_name === null) {
    options.project_name = path.basename(path.resolve(options.project_path));
  }

  return {
    subcommand_name: &#x27;apply&#x27;,
    start_rethinkdb: options.start_rethinkdb,
    rdb_host: options.rdb_host,
    rdb_port: options.rdb_port,
    project_name: options.project_name,
    project_path: options.project_path,
    debug: options.debug,
    update: parse_yes_no_option(parsed.update),
    force: parse_yes_no_option(parsed.force),
    in_file,
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
try {
  fs.accessAsync(opts.schema_file, fs.R_OK | fs.F_OK);
} catch (e) {
  console.error(
    chalk.yellow.bold(&#x27;No .hz/schema.toml file found&#x27;));
  return;
}
const schemaOptions = schema.<span class="apidocCodeKeywordSpan">processApplyConfig</span>({
  project_name: opts.project_name,
  schema_file: opts.schema_file,
  start_rethinkdb: false,
  connect: `${opts.rdb_host}:${opts.rdb_port}`,
  update: true,
  force: false,
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.schema.run" id="apidoc.element.horizon.schema.run">
        function <span class="apidocSignatureSpan">horizon.schema.</span>run
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&#x3e;
Promise.resolve().then(() =&#x3e; {
  const options = processConfig(parseArguments(args));
  // Determine if we are saving or applying and use appropriate run function
  switch (options.subcommand_name) {
  case &#x27;apply&#x27;:
    return runApplyCommand(options);
  case &#x27;save&#x27;:
    return runSaveCommand(options);
  default:
    throw new Error(`Unrecognized schema subcommand: &#x22;${options.subcommand_name}&#x22;`);
  }
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&#x3e; {
    white(&#x27;Validating current schema version&#x27;);
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&#x3e; checkForHzTables)
      .do(() =&#x3e; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&#x3e; green(&#x27; └── Pre-2.0 schema found&#x27;))
      .catch((e) =&#x3e; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don&#x27;t have a Horizon app in this database, or if \
you&#x27;ve already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.schema.runApplyCommand" id="apidoc.element.horizon.schema.runApplyCommand">
        function <span class="apidocSignatureSpan">horizon.schema.</span>runApplyCommand
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(options) =&#x3e; {
  let conn, schema, rdb_server;
  let obsolete_collections = [ ];
  const db = options.project_name;

  const cleanup = () =&#x3e;
    Promise.all([
      conn ? conn.close() : Promise.resolve(),
      rdb_server ? rdb_server.close() : Promise.resolve(),
    ]);

  interrupt.on_interrupt(() =&#x3e; cleanup());

  return Promise.resolve().then(() =&#x3e; {
    if (options.start_rethinkdb) {
      change_to_project_dir(options.project_path);
    }

    return new Promise((resolve, reject) =&#x3e; {
      let schema_toml = &#x27;&#x27;;
      options.in_file.on(&#x27;data&#x27;, (buffer) =&#x3e; (schema_toml += buffer));
      options.in_file.on(&#x27;end&#x27;, () =&#x3e; resolve(schema_toml));
      options.in_file.on(&#x27;error&#x27;, reject);
    });
  }).then((schema_toml) =&#x3e; {
    schema = parse_schema(schema_toml);

    if (options.start_rethinkdb) {
      return start_rdb_server({ quiet: !options.debug }).then((server) =&#x3e; {
        rdb_server = server;
        options.rdb_host = &#x27;localhost&#x27;;
        options.rdb_port = server.driver_port;
      });
    }
  }).then(() =&#x3e;
    r.connect({ host: options.rdb_host,
                port: options.rdb_port,
                user: options.rdb_user,
                password: options.rdb_password,
                timeout: options.rdb_timeout })
  ).then((rdb_conn) =&#x3e; {
    conn = rdb_conn;
    return initialize_metadata(db, conn);
  }).then((initialization_result) =&#x3e; {
    if (initialization_result.tables_created) {
      console.log(&#x27;Initialized new application metadata.&#x27;);
    }
    // Wait for metadata tables to be writable
    return r.expr([ &#x27;hz_collections&#x27;, &#x27;hz_groups&#x27; ])
      .forEach((table) =&#x3e;
        r.db(db).table(table)
          .wait({ waitFor: &#x27;ready_for_writes&#x27;, timeout: 30 }))
      .run(conn);
  }).then(() =&#x3e; {
    // Error if any collections will be removed
    if (!options.update) {
      return r.db(db).table(&#x27;hz_collections&#x27;)
        .filter((row) =&#x3e; row(&#x27;id&#x27;).match(&#x27;^hz_&#x27;).not())
        .getField(&#x27;id&#x27;)
        .coerceTo(&#x27;array&#x27;)
        .setDifference(schema.collections.map((c) =&#x3e; c.id))
        .run(conn)
        .then((res) =&#x3e; {
          if (!options.force &#x26;&#x26; res.length &#x3e; 0) {
            throw new Error(&#x27;Run with &#x22;--force&#x22; to continue.\n&#x27; +
                            &#x27;These collections would be removed along with their data:\n&#x27; +
                            `${res.join(&#x27;, &#x27;)}`);
          }
          obsolete_collections = res;
        });
    }
  }).then(() =&#x3e; {
    if (options.update) {
      // Update groups
      return Promise.all(schema.groups.map((group) =&#x3e; {
        const literal_group = JSON.parse(JSON.stringify(group));
        Object.keys(literal_group.rules).forEach((key) =&#x3e; {
          literal_group.rules[key] = r.literal(literal_group.rules[key]);
        });

        return r.db(db).table(&#x27;hz_groups&#x27;)
          .get(group.id).replace((old_row) =&#x3e;
            r.branch(old_row.eq(null),
                     group,
                     old_row.merge(literal_group)))
          .run(conn).then((res) =&#x3e; {
            if (res.errors) {
              throw new Error(`Failed to update group: ${res.first_error}`);
            }
          });
      }));
    } else {
      // Replace and remove groups
      const groups_obj = { };
      schema.groups.forEach((g) =&#x3e; { groups_obj[g.id] = g; });

      return Promise.all([
        r.expr(groups_obj).do((groups) =&#x3e;
          r.db(db).table(&#x27;hz_groups&#x27;)
            .replace((old_row) =&#x3e;
              r.branch(groups.hasFields(old_row(&#x27;id&#x27;)),
                       old_row,
                       null))
          ).run(conn).then((res) =&#x3e; {
            if (res.errors) {
              throw new Error(`Failed to write groups: ${res.first_error}`);
            }
          }),
        r.db(db).table(&#x27;hz_groups&#x27;)
          .insert(schema.groups, { conflict: &#x27;replace&#x27; })
          .run(conn).then((res) =&#x3e; {
            if (res.errors) {
              throw new Error(`Failed to write groups: ${res.first_error}`);
            }
          }),
      ]);
    }
  }).then(() =&#x3e; {
    // Ensure all collections exist and remove any obsolete collections
    const promise ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    project_name: opts.project_name,
    schema_file: opts.schema_file,
    start_rethinkdb: false,
    connect: `${opts.rdb_host}:${opts.rdb_port}`,
    update: true,
    force: false,
  });
  return schema.<span class="apidocCodeKeywordSpan">runApplyCommand</span>(schemaOptions);
}
  }).then(() =&#x3e; {
console.log(&#x27;Starting Horizon...&#x27;);
hz_server = start_horizon_server(http_servers, opts);

return new Promise((resolve, reject) =&#x3e; {
  const timeoutObject = setTimeout(() =&#x3e; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.schema.runSaveCommand" id="apidoc.element.horizon.schema.runSaveCommand">
        function <span class="apidocSignatureSpan">horizon.schema.</span>runSaveCommand
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(options) =&#x3e; {
  let conn, rdb_server;
  const db = options.project_name;

  const cleanup = () =&#x3e;
    Promise.all([
      conn ? conn.close() : Promise.resolve(),
      rdb_server ? rdb_server.close() : Promise.resolve(),
    ]);

  interrupt.on_interrupt(() =&#x3e; cleanup());

  return Promise.resolve().then(() =&#x3e; {
    if (options.start_rethinkdb) {
      change_to_project_dir(options.project_path);
    }
  }).then(() =&#x3e; {
    if (options.start_rethinkdb) {
      return start_rdb_server({ quiet: !options.debug }).then((server) =&#x3e; {
        rdb_server = server;
        options.rdb_host = &#x27;localhost&#x27;;
        options.rdb_port = server.driver_port;
      });
    }
  }).then(() =&#x3e;
    r.connect({ host: options.rdb_host,
                port: options.rdb_port,
                user: options.rdb_user,
                password: options.rdb_password,
                timeout: options.rdb_timeout })
  ).then((rdb_conn) =&#x3e; {
    conn = rdb_conn;
    return r.db(db).wait({ waitFor: &#x27;ready_for_reads&#x27;, timeout: 30 }).run(conn);
  }).then(() =&#x3e;
    r.object(&#x27;collections&#x27;,
             r.db(db).table(&#x27;hz_collections&#x27;)
               .filter((row) =&#x3e; row(&#x27;id&#x27;).match(&#x27;^hz_&#x27;).not())
               .coerceTo(&#x27;array&#x27;)
               .map((row) =&#x3e;
                 row.merge({ indexes: r.db(db).table(row(&#x27;id&#x27;)).indexList() })),
             &#x27;groups&#x27;, r.db(db).table(&#x27;hz_groups&#x27;).coerceTo(&#x27;array&#x27;))
      .run(conn)
  ).then((res) =&#x3e;
    new Promise((resolve) =&#x3e; {
      // Only rename old file if saving to default .hz/schema.toml
      if (options.out_file === &#x27;.hz/schema.toml&#x27; &#x26;&#x26;
          file_exists(options.out_file)) {
        // Rename existing file to have the current time appended to its name
        const oldPath = path.resolve(options.out_file);
        const newPath = `${path.resolve(options.out_file)}.${new Date().toISOString()}`;
        fs.renameSync(oldPath, newPath);
      }

      const output = (options.out_file === &#x27;-&#x27;) ? process.stdout :
        fs.createWriteStream(options.out_file, { flags: &#x27;w&#x27;, defaultEncoding: &#x27;utf8&#x27; });

      // Output toml_str to schema.toml
      const toml_str = schema_to_toml(res.collections, res.groups);
      output.end(toml_str, resolve);
    })
  ).then(cleanup).catch((err) =&#x3e; cleanup().then(() =&#x3e; { throw err; }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.serve" id="apidoc.module.horizon.serve">module horizon.serve</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.serve.parseArguments" id="apidoc.element.horizon.serve.parseArguments">
        function <span class="apidocSignatureSpan">horizon.serve.</span>parseArguments
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&#x3e; {
  const parser = new argparse.ArgumentParser({ prog: &#x27;hz serve&#x27; });

  parser.addArgument([ &#x27;project_path&#x27; ],
    { type: &#x27;string&#x27;, nargs: &#x27;?&#x27;,
      help: &#x27;Change to this directory before serving&#x27; });

  parser.addArgument([ &#x27;--project-name&#x27;, &#x27;-n&#x27; ],
    { type: &#x27;string&#x27;, action: &#x27;store&#x27;, metavar: &#x27;NAME&#x27;,
      help: &#x27;Name of the Horizon project. Determines the name of &#x27; +
            &#x27;the RethinkDB database that stores the project data.&#x27; });

  parser.addArgument([ &#x27;--bind&#x27;, &#x27;-b&#x27; ],
    { type: &#x27;string&#x27;, action: &#x27;append&#x27;, metavar: &#x27;HOST&#x27;,
      help: &#x27;Local hostname to serve horizon on (repeatable).&#x27; });

  parser.addArgument([ &#x27;--port&#x27;, &#x27;-p&#x27; ],
    { type: &#x27;int&#x27;, metavar: &#x27;PORT&#x27;,
      help: &#x27;Local port to serve horizon on.&#x27; });

  parser.addArgument([ &#x27;--connect&#x27;, &#x27;-c&#x27; ],
    { type: &#x27;string&#x27;, metavar: &#x27;HOST:PORT&#x27;,
      help: &#x27;Host and port of the RethinkDB server to connect to.&#x27; });

  parser.addArgument([ &#x27;--rdb-timeout&#x27; ],
    { type: &#x27;int&#x27;, metavar: &#x27;TIMEOUT&#x27;,
      help: &#x27;Timeout period in seconds for the RethinkDB connection to be opened&#x27; });

  parser.addArgument([ &#x27;--rdb-user&#x27; ],
    { type: &#x27;string&#x27;, metavar: &#x27;USER&#x27;,
      help: &#x27;RethinkDB User&#x27; });

  parser.addArgument([ &#x27;--rdb-password&#x27; ],
    { type: &#x27;string&#x27;, metavar: &#x27;PASSWORD&#x27;,
      help: &#x27;RethinkDB Password&#x27; });

  parser.addArgument([ &#x27;--key-file&#x27; ],
    { type: &#x27;string&#x27;, metavar: &#x27;PATH&#x27;,
      help: &#x27;Path to the key file to use, defaults to &#x22;./horizon-key.pem&#x22;.&#x27; });

  parser.addArgument([ &#x27;--cert-file&#x27; ],
    { type: &#x27;string&#x27;, metavar: &#x27;PATH&#x27;,
      help: &#x27;Path to the cert file to use, defaults to &#x22;./horizon-cert.pem&#x22;.&#x27; });

  parser.addArgument([ &#x27;--token-secret&#x27; ],
    { type: &#x27;string&#x27;, metavar: &#x27;SECRET&#x27;,
      help: &#x27;Key for signing jwts&#x27; });

  parser.addArgument([ &#x27;--allow-unauthenticated&#x27; ],
    { type: &#x27;string&#x27;, metavar: &#x27;yes|no&#x27;, constant: &#x27;yes&#x27;, nargs: &#x27;?&#x27;,
      help: &#x27;Whether to allow unauthenticated Horizon connections.&#x27; });

  parser.addArgument([ &#x27;--allow-anonymous&#x27; ],
    { type: &#x27;string&#x27;, metavar: &#x27;yes|no&#x27;, constant: &#x27;yes&#x27;, nargs: &#x27;?&#x27;,
      help: &#x27;Whether to allow anonymous Horizon connections.&#x27; });

  parser.addArgument([ &#x27;--debug&#x27; ],
    { type: &#x27;string&#x27;, metavar: &#x27;yes|no&#x27;, constant: &#x27;yes&#x27;, nargs: &#x27;?&#x27;,
      help: &#x27;Enable debug logging.&#x27; });

  parser.addArgument([ &#x27;--secure&#x27; ],
    { type: &#x27;string&#x27;, metavar: &#x27;yes|no&#x27;, constant: &#x27;yes&#x27;, nargs: &#x27;?&#x27;,
      help: &#x27;Serve secure websockets, requires --key-file and &#x27; +
      &#x27;--cert-file if true, on by default.&#x27; });

  parser.addArgument([ &#x27;--start-rethinkdb&#x27; ],
    { type: &#x27;string&#x27;, metavar: &#x27;yes|no&#x27;, constant: &#x27;yes&#x27;, nargs: &#x27;?&#x27;,
      help: &#x27;Start up a RethinkDB server in the current directory&#x27; });

  parser.addArgument([ &#x27;--auto-create-collection&#x27; ],
    { type: &#x27;string&#x27;, metavar: &#x27;yes|no&#x27;, constant: &#x27;yes&#x27;, nargs: &#x27;?&#x27;,
      help: &#x27;Create collections used by requests if they do not exist.&#x27; });

  parser.addArgument([ &#x27;--auto-create-index&#x27; ],
    { type: &#x27;string&#x27;, metavar: &#x27;yes|no&#x27;, constant: &#x27;yes&#x27;, nargs: &#x27;?&#x27;,
      help: &#x27;Create indexes used by requests if they do not exist.&#x27; });

  parser.addArgument([ &#x27;--permissions&#x27; ],
    { type: &#x27;string&#x27;, metavar: &#x27;yes|no&#x27;, constant: &#x27;yes&#x27;, nargs: &#x27;?&#x27;,
      help: &#x27;Enables or disables checking permissions on requests.&#x27; });

  parser.addArgument([ &#x27;--serve-static&#x27; ],
    { type: &#x27;string&#x27;, metavar: &#x27;PATH&#x27;, nargs: &#x27;?&#x27;, constant: &#x27;./dist&#x27;,
      help: &#x27;Serve static files from a directory, defaults to &#x22;./dist&#x22;.&#x27; });

  parser.addArgument([ &#x27;--dev&#x27; ],
    { action: &#x27;storeTrue&#x27;,
      help: &#x27;Runs the server in development mode, this sets &#x27; +
      &#x27;--secure=no, &#x27; +
      &#x27;--permissions=no, &#x27; +
      &#x27;--auto-create-collection=yes, &#x27; +
      &#x27;--auto-create-index=yes, &#x27; +
      &#x27;--start-rethinkdb=yes, &#x27; +
      &#x27;--allow-unauthenticated=yes, &#x27; +
      &#x27;--allow-anonymous=yes &#x27; +
      &#x27;and --serve-static=./dist.&#x27; });

  parser.addArgument([ &#x27;--schema-file&#x27; ],
    { type: &#x27;string&#x27;, metavar: &#x27;SCHEMA_FILE_PATH&#x27;,
      help: &#x27;Path to the schema file to use, &#x27; +
      &#x27;will attempt to apply schema before starting Horizon server&#x22;.&#x27; });

  parser.a ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.serve.processConfig" id="apidoc.element.horizon.serve.processConfig">
        function <span class="apidocSignatureSpan">horizon.serve.</span>processConfig
        <span class="apidocSignatureSpan">(parsed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(parsed) =&#x3e; {
  let options;

  options = config.default_options();

  options = config.merge_options(options,
    config.read_from_config_file(parsed.project_path));

  options = config.merge_options(options,
    config.read_from_secrets_file(parsed.project_path));

  options = config.merge_options(options, config.read_from_env());

  options = config.merge_options(options, config.read_from_flags(parsed));

  if (options.project_name === null) {
    options.project_name = path.basename(path.resolve(options.project_path));
  }

  if (options.bind.indexOf(&#x27;all&#x27;) !== -1) {
    options.bind = [ &#x27;0.0.0.0&#x27; ];
  }

  if (!options.rdb_host) {
    options.rdb_host = default_rdb_host;
  }

  if (!options.rdb_port) {
    options.rdb_port = default_rdb_port;
  }

  if (!options.rdb_timeout) {
    options.rdb_timeout = default_rdb_timeout;
  }

  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.serve.run" id="apidoc.element.horizon.serve.run">
        function <span class="apidocSignatureSpan">horizon.serve.</span>run
        <span class="apidocSignatureSpan">(args, interruptor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args, interruptor) =&#x3e; {
  let opts, http_servers, hz_server, rdb_server;
  const old_log_level = logger.level;

  const cleanup = () =&#x3e; {
    logger.level = old_log_level;

    return Promise.all([
      hz_server ? hz_server.close() : Promise.resolve(),
      rdb_server ? rdb_server.close() : Promise.resolve(),
      http_servers ? Promise.all(http_servers.map((s) =&#x3e;
        new Promise((resolve) =&#x3e; s.close(resolve)))) : Promise.resolve(),
    ]);
  };

  interrupt.on_interrupt(() =&#x3e; cleanup());

  return Promise.resolve().then(() =&#x3e; {
    opts = processConfig(parseArguments(args));
    logger.level = opts.debug ? &#x27;debug&#x27; : &#x27;warn&#x27;;

    if (!opts.secure &#x26;&#x26; opts.auth &#x26;&#x26; Array.from(Object.keys(opts.auth)).length &#x3e; 0) {
      logger.warn(&#x27;Authentication requires that the server be accessible via HTTPS. &#x27; +
                  &#x27;Either specify &#x22;secure=true&#x22; or use a reverse proxy.&#x27;);
    }

    change_to_project_dir(opts.project_path);

    if (opts.secure) {
      return create_secure_servers(opts);
    } else {
      return create_insecure_servers(opts);
    }
  }).then((servers) =&#x3e; {
    http_servers = servers;

    if (opts.start_rethinkdb) {
      return start_rdb_server().then((server) =&#x3e; {
        rdb_server = server;

        // Don&#x27;t need to check for host, always localhost.
        opts.rdb_host = &#x27;localhost&#x27;;
        opts.rdb_port = server.driver_port;

        console.log(&#x27;RethinkDB&#x27;);
        console.log(`   ├── Admin interface: http://localhost:${server.http_port}`);
        console.log(`   └── Drivers can connect to port ${server.driver_port}`);
      });
    }
  }).then(() =&#x3e; {
    // Ensure schema from schema.toml file is set
    if (opts.schema_file) {
      console.log(`Ensuring schema &#x22;${opts.schema_file}&#x22; is applied`);
      try {
        fs.accessAsync(opts.schema_file, fs.R_OK | fs.F_OK);
      } catch (e) {
        console.error(
          chalk.yellow.bold(&#x27;No .hz/schema.toml file found&#x27;));
        return;
      }
      const schemaOptions = schema.processApplyConfig({
        project_name: opts.project_name,
        schema_file: opts.schema_file,
        start_rethinkdb: false,
        connect: `${opts.rdb_host}:${opts.rdb_port}`,
        update: true,
        force: false,
      });
      return schema.runApplyCommand(schemaOptions);
    }
  }).then(() =&#x3e; {
    console.log(&#x27;Starting Horizon...&#x27;);
    hz_server = start_horizon_server(http_servers, opts);

    return new Promise((resolve, reject) =&#x3e; {
      const timeoutObject = setTimeout(() =&#x3e; {
        reject(new Error(&#x27;Horizon failed to start after 30 seconds.\n&#x27; +
                         &#x27;Try running hz serve again with the --debug flag&#x27;));
      }, TIMEOUT_30_SECONDS);

      hz_server.ready().then(() =&#x3e; {
        clearTimeout(timeoutObject);
        console.log(chalk.green.bold(&#x27;🌄 Horizon ready for connections&#x27;));
        resolve(hz_server);
      }).catch(reject);
    });
  }).then(() =&#x3e; {
    if (opts.auth) {
      for (const name in opts.auth) {
        const provider = horizon_server.auth[name];
        if (!provider) {
          throw new Error(`Unrecognized auth provider &#x22;${name}&#x22;`);
        }
        hz_server.add_auth_provider(provider,
                                    Object.assign({}, { path: name }, opts.auth[name]));
      }
    }
  }).then(() =&#x3e; {
    // Automatically open up index.html in the `dist` directory only if
    //  `--open` flag specified and an index.html exists in the directory.
    if (opts.open &#x26;&#x26; opts.serve_static) {
      try {
        // Check if index.html exists and readable in serve static_static directory
        fs.accessSync(`${opts.serve_static}/index.html`, fs.R_OK | fs.F_OK);
        // Determine scheme from options
        const scheme = opts.secure ? &#x27;https://&#x27; : &#x27;http://&#x27;;
        // Open up index.html in default browser
        console.log(&#x27;Attempting open of index.html in default browser&#x27;);
        open(`${scheme}${opts.bind}:${opts.port}/index.html`);
      } catch (open_err) {
        console.log(chalk.red(&#x27;Error occurred while trying to open &#x27; +
                              `${opts.serve_sta ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&#x3e; {
    white(&#x27;Validating current schema version&#x27;);
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&#x3e; checkForHzTables)
      .do(() =&#x3e; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&#x3e; green(&#x27; └── Pre-2.0 schema found&#x27;))
      .catch((e) =&#x3e; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don&#x27;t have a Horizon app in this database, or if \
you&#x27;ve already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.start_rdb_server" id="apidoc.module.horizon.start_rdb_server">module horizon.start_rdb_server</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.start_rdb_server.start_rdb_server" id="apidoc.element.horizon.start_rdb_server.start_rdb_server">
        function <span class="apidocSignatureSpan">horizon.</span>start_rdb_server
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(options) =&#x3e; new RethinkdbServer(options || { }).ready()</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.start_rdb_server.r" id="apidoc.element.horizon.start_rdb_server.r">
        function <span class="apidocSignatureSpan">horizon.start_rdb_server.</span>r
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">r = function () {
  var args;
  args = 1 &#x3c;= arguments.length ? slice.call(arguments, 0) : [];
  return rethinkdb.expr.apply(rethinkdb, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.version" id="apidoc.module.horizon.version">module horizon.version</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.version.run" id="apidoc.element.horizon.version.run">
        function <span class="apidocSignatureSpan">horizon.version.</span>run
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&#x3e;
Promise.resolve().then(() =&#x3e; {
  if (args &#x26;&#x26; args.length) {
    throw new Error(&#x27;create-cert takes no arguments&#x27;);
  }
  console.info(package_json.version);
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&#x3e; {
    white(&#x27;Validating current schema version&#x27;);
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&#x3e; checkForHzTables)
      .do(() =&#x3e; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&#x3e; green(&#x27; └── Pre-2.0 schema found&#x27;))
      .catch((e) =&#x3e; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don&#x27;t have a Horizon app in this database, or if \
you&#x27;ve already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
