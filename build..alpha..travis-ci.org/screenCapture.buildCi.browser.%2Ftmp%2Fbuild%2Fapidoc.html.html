<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/rethinkdb/horizon#readme">horizon (v2.0.0)</a>
</h1>
<h4>An open-source developer platform for building realtime, scalable web apps.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon">module horizon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.start_rdb_server">
            function <span class="apidocSignatureSpan">horizon.</span>start_rdb_server
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>create_cert</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>init</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>interrupt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>make_token</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>migrate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>schema</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>serve</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.config">module horizon.config</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.config.default_options">
            function <span class="apidocSignatureSpan">horizon.config.</span>default_options
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.config.merge_options">
            function <span class="apidocSignatureSpan">horizon.config.</span>merge_options
            <span class="apidocSignatureSpan">(old_options, new_options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.config.parse_connect">
            function <span class="apidocSignatureSpan">horizon.config.</span>parse_connect
            <span class="apidocSignatureSpan">(connect, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.config.read_from_config_file">
            function <span class="apidocSignatureSpan">horizon.config.</span>read_from_config_file
            <span class="apidocSignatureSpan">(project_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.config.read_from_env">
            function <span class="apidocSignatureSpan">horizon.config.</span>read_from_env
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.config.read_from_flags">
            function <span class="apidocSignatureSpan">horizon.config.</span>read_from_flags
            <span class="apidocSignatureSpan">(parsed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.config.read_from_secrets_file">
            function <span class="apidocSignatureSpan">horizon.config.</span>read_from_secrets_file
            <span class="apidocSignatureSpan">(projectPath)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.config.</span>default_config_file</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.config.</span>default_secrets_file</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.create_cert">module horizon.create_cert</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.create_cert.run">
            function <span class="apidocSignatureSpan">horizon.create_cert.</span>run
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.create_cert.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.init">module horizon.init</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.init.run">
            function <span class="apidocSignatureSpan">horizon.init.</span>run
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.init.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.interrupt">module horizon.interrupt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.interrupt.interrupt">
            function <span class="apidocSignatureSpan">horizon.</span>interrupt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.interrupt.on_interrupt">
            function <span class="apidocSignatureSpan">horizon.interrupt.</span>on_interrupt
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.make_token">module horizon.make_token</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.make_token.run">
            function <span class="apidocSignatureSpan">horizon.make_token.</span>run
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.make_token.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.migrate">module horizon.migrate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.migrate.run">
            function <span class="apidocSignatureSpan">horizon.migrate.</span>run
            <span class="apidocSignatureSpan">(cmdArgs)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.migrate.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.schema">module horizon.schema</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.schema.parse_schema">
            function <span class="apidocSignatureSpan">horizon.schema.</span>parse_schema
            <span class="apidocSignatureSpan">(schema_toml)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.schema.processApplyConfig">
            function <span class="apidocSignatureSpan">horizon.schema.</span>processApplyConfig
            <span class="apidocSignatureSpan">(parsed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.schema.run">
            function <span class="apidocSignatureSpan">horizon.schema.</span>run
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.schema.runApplyCommand">
            function <span class="apidocSignatureSpan">horizon.schema.</span>runApplyCommand
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.schema.runSaveCommand">
            function <span class="apidocSignatureSpan">horizon.schema.</span>runSaveCommand
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.schema.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.serve">module horizon.serve</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.serve.parseArguments">
            function <span class="apidocSignatureSpan">horizon.serve.</span>parseArguments
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.serve.processConfig">
            function <span class="apidocSignatureSpan">horizon.serve.</span>processConfig
            <span class="apidocSignatureSpan">(parsed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.serve.run">
            function <span class="apidocSignatureSpan">horizon.serve.</span>run
            <span class="apidocSignatureSpan">(args, interruptor)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.serve.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.start_rdb_server">module horizon.start_rdb_server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.start_rdb_server.start_rdb_server">
            function <span class="apidocSignatureSpan">horizon.</span>start_rdb_server
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.start_rdb_server.r">
            function <span class="apidocSignatureSpan">horizon.start_rdb_server.</span>r
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.version">module horizon.version</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.version.run">
            function <span class="apidocSignatureSpan">horizon.version.</span>run
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.version.</span>description</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon" id="apidoc.module.horizon">module horizon</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.start_rdb_server" id="apidoc.element.horizon.start_rdb_server">
        function <span class="apidocSignatureSpan">horizon.</span>start_rdb_server
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(options) =&gt; new RethinkdbServer(options || { }).ready()</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.config" id="apidoc.module.horizon.config">module horizon.config</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.config.default_options" id="apidoc.element.horizon.config.default_options">
        function <span class="apidocSignatureSpan">horizon.config.</span>default_options
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&gt; ({
  config: null,
  debug: false,
  // Default to current directory for path
  project_path: '.',
  // Default to current directory name for project name
  project_name: null,

  bind: [ 'localhost' ],
  port: 8181,

  start_rethinkdb: false,
  serve_static: null,
  open: false,

  secure: true,
  permissions: true,
  key_file: './horizon-key.pem',
  cert_file: './horizon-cert.pem',
  schema_file: null,

  auto_create_collection: false,
  auto_create_index: false,

  rdb_host: null,
  rdb_port: null,
  rdb_user: null,
  rdb_password: null,
  rdb_timeout: null,

  token_secret: null,
  allow_anonymous: false,
  allow_unauthenticated: false,
  auth_redirect: '/',
  access_control_allow_origin: '',

  auth: { },
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...

return parser.parseArgs(args);
};

const processConfig = (parsed) =&gt; {
let options;

options = config.<span class="apidocCodeKeywordSpan">default_options</span>();

options = config.merge_options(
  options, config.read_from_config_file(parsed.project_path));
options = config.merge_options(
  options, config.read_from_secrets_file(parsed.project_path));
options = config.merge_options(options, config.read_from_env());
options = config.merge_options(options, config.read_from_flags(parsed));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.config.merge_options" id="apidoc.element.horizon.config.merge_options">
        function <span class="apidocSignatureSpan">horizon.config.</span>merge_options
        <span class="apidocSignatureSpan">(old_options, new_options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(old_options, new_options) =&gt; {
  // Disable start_rethinkdb if it was enabled by dev mode but we already have a host
  if (new_options._start_rethinkdb_implicit) {
    if (old_options.rdb_host) {
      delete new_options.start_rethinkdb;
    }
  } else if (new_options.start_rethinkdb &amp;&amp; new_options.rdb_host) {
    throw new Error('Cannot provide both --start-rethinkdb and --connect.');
  }

  for (const key in new_options) {
    if (key === 'rdb_host') {
      old_options.start_rethinkdb = false;
    }

    if (key === 'auth') {
      for (const provider in new_options.auth) {
        old_options.auth[provider] = old_options.auth[provider] || { };
        for (const field in new_options.auth[provider]) {
          old_options.auth[provider][field] = new_options.auth[provider][field];
        }
      }
    } else {
      old_options[key] = new_options[key];
    }
  }

  return old_options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

const processConfig = (parsed) =&gt; {
let options;

options = config.default_options();

options = config.<span class="apidocCodeKeywordSpan">merge_options</span>(
  options, config.read_from_config_file(parsed.project_path));
options = config.merge_options(
  options, config.read_from_secrets_file(parsed.project_path));
options = config.merge_options(options, config.read_from_env());
options = config.merge_options(options, config.read_from_flags(parsed));

if (options.project_name === null) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.config.parse_connect" id="apidoc.element.horizon.config.parse_connect">
        function <span class="apidocSignatureSpan">horizon.config.</span>parse_connect
        <span class="apidocSignatureSpan">(connect, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(connect, config) =&gt; {
  // support rethinkdb:// style connection uri strings
  // expects rethinkdb://host:port` at a minimum but can optionally take a user:pass and db
  // e.g. rethinkdb://user:pass@host:port/db
  const rdb_uri = url.parse(connect);
  if (rdb_uri.protocol === 'rethinkdb:') {
    if (rdb_uri.hostname) {
      config.rdb_host = rdb_uri.hostname;
      config.rdb_port = rdb_uri.port || default_rdb_port;

      // check for user/pass
      if (rdb_uri.auth) {
        const user_pass = rdb_uri.auth.split(':');
        config.rdb_user = user_pass[0];
        config.rdb_password = user_pass[1];
      }

      // set the project name based on the db
      if (rdb_uri.path &amp;&amp; rdb_uri.path.replace('/', '') !== '') {
        config.project_name = rdb_uri.path.replace('/', '');
      }
    } else {
      throw new Error(`Expected --connect rethinkdb://HOST, but found "${connect}".`);
    }
  } else {
    // support legacy HOST:PORT connection strings
    const host_port = connect.split(':');
    if (host_port.length === 1) {
      config.rdb_host = host_port[0];
      config.rdb_port = default_rdb_port;
    } else if (host_port.length === 2) {
      config.rdb_host = host_port[0];
      config.rdb_port = parseInt(host_port[1]);
      if (isNaN(config.rdb_port) || config.rdb_port &lt; 0 || config.rdb_port &gt; 65535) {
        throw new Error(`Invalid port: "${host_port[1]}".`);
      }
    } else {
      throw new Error(`Expected --connect HOST:PORT, but found "${connect}".`);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    rdb_password: parsed.rdb_password || confOptions.rdb_password || '',
    start_rethinkdb: parse_yes_no_option(parsed.start_rethinkdb),
    skip_backup: parse_yes_no_option(parsed.skip_backup),
    nonportable_backup: parse_yes_no_option(parsed.nonportable_backup),
  };
  // sets rdb_host and rdb_port from connect if necessary
  if (parsed.connect) {
    config.<span class="apidocCodeKeywordSpan">parse_connect</span>(parsed.connect, options);
  }

  if (options.project_name == null) {
    throw new NiceError('No project_name given', {
      description: `\
The project_name is needed to migrate from the v1.x format the v.2.0 format. \
It wasn't passed on the command line or found in your config.`,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.config.read_from_config_file" id="apidoc.element.horizon.config.read_from_config_file">
        function <span class="apidocSignatureSpan">horizon.config.</span>read_from_config_file
        <span class="apidocSignatureSpan">(project_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(project_path) =&gt; {
  const config = { auth: { } };

  let fileData, configFilename, fileConfig;

  if (project_path) {
    configFilename = `${project_path}/${default_config_file}`;
  } else {
    configFilename = default_config_file;
  }

  try {
    fileData = fs.readFileSync(configFilename);
  } catch (err) {
    return config;
  }

  try {
    fileConfig = toml.parse(fileData);
  } catch (e) {
    if (e.name === 'SyntaxError') {
      throw new NiceError(
        `There was a syntax error when parsing ${configFilename}`, {
          description: `Something was wrong with the format of \
${configFilename}, causing it not be a valid TOML file.`,
          src: {
            filename: configFilename,
            contents: fileData,
            line: e.line,
            column: e.column,
          },
          suggestions: [
            'Check that all strings values have quotes around them',
            'Check that key/val pairs use equals and not colons',
            'See https://github.com/toml-lang/toml#user-content-spec',
          ],
        });
    } else {
      throw e;
    }
  }
  for (const field in fileConfig) {
    if (field === 'connect') {
      parse_connect(fileConfig.connect, config);
    } else if (yes_no_options.indexOf(field) !== -1) {
      config[field] = parse_yes_no_option(fileConfig[field], field);
    } else if (default_options[field] !== undefined) {
      config[field] = fileConfig[field];
    } else {
      throw new Error(`Unknown config parameter: "${field}".`);
    }
  }
  return config;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

const processConfig = (parsed) =&gt; {
let options;

options = config.default_options();

options = config.merge_options(
  options, config.<span class="apidocCodeKeywordSpan">read_from_config_file</span>(parsed.project_path));
options = config.merge_options(
  options, config.read_from_secrets_file(parsed.project_path));
options = config.merge_options(options, config.read_from_env());
options = config.merge_options(options, config.read_from_flags(parsed));

if (options.project_name === null) {
  options.project_name = path.basename(path.resolve(options.project_path));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.config.read_from_env" id="apidoc.element.horizon.config.read_from_env">
        function <span class="apidocSignatureSpan">horizon.config.</span>read_from_env
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&gt; {
  const config = { auth: { } };
  for (const env_var in process.env) {
    const matches = env_regex.exec(env_var);
    if (matches &amp;&amp; matches[1]) {
      const destVarName = matches[1].toLowerCase();
      const varPath = destVarName.split('_');
      const value = process.env[env_var];

      if (destVarName === 'connect') {
        parse_connect(value, config);
      } else if (destVarName === 'bind') {
        config[destVarName] = value.split(',');
      } else if (varPath[0] === 'auth') {
        if (varPath.length !== 3) {
          console.log(`Ignoring malformed Horizon environment variable: "${env_var}", ` +
                      'should be HZ_AUTH_{PROVIDER}_{OPTION}.');
        } else {
          config.auth[varPath[1]] = config.auth[varPath[1]] || { };
          config.auth[varPath[1]][varPath[2]] = value;
        }
      } else if (yes_no_options.indexOf(destVarName) !== -1) {
        config[destVarName] = parse_yes_no_option(value, destVarName);
      } else if (default_options[destVarName] !== undefined) {
        config[destVarName] = value;
      }
    }
  }

  return config;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = config.default_options();

options = config.merge_options(
  options, config.read_from_config_file(parsed.project_path));
options = config.merge_options(
  options, config.read_from_secrets_file(parsed.project_path));
options = config.merge_options(options, config.<span class="apidocCodeKeywordSpan">read_from_env</span>());
options = config.merge_options(options, config.read_from_flags(parsed));

if (options.project_name === null) {
  options.project_name = path.basename(path.resolve(options.project_path));
}

return Object.assign(options, { user: parsed.user });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.config.read_from_flags" id="apidoc.element.horizon.config.read_from_flags">
        function <span class="apidocSignatureSpan">horizon.config.</span>read_from_flags
        <span class="apidocSignatureSpan">(parsed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(parsed) =&gt; {
  const config = { auth: { } };

  // Dev mode
  if (parsed.dev) {
    config.access_control_allow_origin = '*';
    config.allow_unauthenticated = true;
    config.allow_anonymous = true;
    config.secure = false;
    config.permissions = false;
    config.start_rethinkdb = true;
    config.auto_create_collection = true;
    config.auto_create_index = true;
    config.serve_static = 'dist';
    config._dev_flag_used = true;

    if (parsed.start_rethinkdb === null || parsed.start_rethinkdb === undefined) {
      config._start_rethinkdb_implicit = true;
    }
  }

  for (const key in parsed) {
    if (key === 'auth' &amp;&amp; parsed.auth != null) {
      // Auth options
      parsed.auth.forEach((auth_options) =&gt; {
        const params = auth_options.split(',');
        if (params.length !== 3) {
          throw new Error(`Expected --auth PROVIDER,ID,SECRET, but found "${auth_options}"`);
        }
        config.auth[params[0]] = { id: params[1], secret: params[2] };
      });
    } else if (key === 'connect' &amp;&amp; parsed.connect != null) {
      // Normalize RethinkDB connection options
      parse_connect(parsed.connect, config);
    } else if (yes_no_options.indexOf(key) !== -1 &amp;&amp; parsed[key] != null) {
      // Simple 'yes' or 'no' (or 'true' or 'false') flags
      config[key] = parse_yes_no_option(parsed[key], key);
    } else if (parsed[key] != null) {
      config[key] = parsed[key];
    }
  }

  return config;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  options = config.default_options();

  options = config.merge_options(
    options, config.read_from_config_file(parsed.project_path));
  options = config.merge_options(
    options, config.read_from_secrets_file(parsed.project_path));
  options = config.merge_options(options, config.read_from_env());
  options = config.merge_options(options, config.<span class="apidocCodeKeywordSpan">read_from_flags</span>(parsed));

  if (options.project_name === null) {
    options.project_name = path.basename(path.resolve(options.project_path));
  }

  return Object.assign(options, { user: parsed.user });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.config.read_from_secrets_file" id="apidoc.element.horizon.config.read_from_secrets_file">
        function <span class="apidocSignatureSpan">horizon.config.</span>read_from_secrets_file
        <span class="apidocSignatureSpan">(projectPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(projectPath) =&gt; {
  const config = { auth: { } };

  let fileData, secretsFilename;

  if (projectPath) {
    secretsFilename = `${projectPath}/${default_secrets_file}`;
  } else {
    secretsFilename = default_secrets_file;
  }

  try {
    fileData = fs.readFileSync(secretsFilename);
  } catch (err) {
    return config;
  }

  const fileConfig = toml.parse(fileData);
  for (const field in fileConfig) {
    if (field === 'connect') {
      parse_connect(fileConfig.connect, config);
    } else if (yes_no_options.indexOf(field) !== -1) {
      config[field] = parse_yes_no_option(fileConfig[field], field);
    } else if (default_options[field] !== undefined) {
      config[field] = fileConfig[field];
    } else {
      throw new Error(`Unknown config parameter: "${field}".`);
    }
  }

  return config;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
let options;

options = config.default_options();

options = config.merge_options(
  options, config.read_from_config_file(parsed.project_path));
options = config.merge_options(
  options, config.<span class="apidocCodeKeywordSpan">read_from_secrets_file</span>(parsed.project_path));
options = config.merge_options(options, config.read_from_env());
options = config.merge_options(options, config.read_from_flags(parsed));

if (options.project_name === null) {
  options.project_name = path.basename(path.resolve(options.project_path));
}
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.create_cert" id="apidoc.module.horizon.create_cert">module horizon.create_cert</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.create_cert.run" id="apidoc.element.horizon.create_cert.run">
        function <span class="apidocSignatureSpan">horizon.create_cert.</span>run
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&gt; {
  if (args.length) {
    throw new Error('create-cert takes no arguments');
  }

  // TODO: user configuration?
  const settings = {
    binaryName: 'openssl',
    keyOutName: 'horizon-key.pem',
    certOutName: 'horizon-cert.pem',
    algo: 'rsa',
    bits: '2048',
    days: '365',
  };

  // generate the arguments to the command
  const binArgs = [ 'req', '-x509', '-nodes', '-batch',
    '-newkey', `${settings.algo}:${settings.bits}`,
    '-keyout', settings.keyOutName,
    '-out', settings.certOutName,
    '-days', settings.days,
  ];

  return new Promise((resolve, reject) =&gt; {
    hasbin(settings.binaryName, (hasOpenSSL) =&gt; {
      // show the invocation that's about to be run
      console.log(`&gt; ${settings.binaryName} ${binArgs.join(' ')}`);

      // if we don't have openssl, bail
      if (!hasOpenSSL) {
        reject(new Error(`Missing ${settings.binaryName}. Make sure it is on the path.`));
      }

      // otherwise start openssl
      const sslProc = spawn(settings.binaryName, binArgs);

      // pipe output appropriately
      sslProc.stdout.pipe(process.stdout, { end: false });
      sslProc.stderr.pipe(process.stderr, { end: false });

      // say nice things to the user when it's done
      sslProc.on('error', reject);
      sslProc.on('close', (code) =&gt; {
        if (code) {
          reject(new Error(`OpenSSL failed with code ${code}.`));
        } else {
          console.log('Everything seems to be fine. ' +
                      'Remember to add your shiny new certificates to your Horizon config!');
          resolve();
        }
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&gt; {
    white('Validating current schema version');
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&gt; checkForHzTables)
      .do(() =&gt; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&gt; green(' â””â”€â”€ Pre-2.0 schema found'))
      .catch((e) =&gt; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don't have a Horizon app in this database, or if \
you've already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.init" id="apidoc.module.horizon.init">module horizon.init</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.init.run" id="apidoc.element.horizon.init.run">
        function <span class="apidocSignatureSpan">horizon.init.</span>run
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&gt;
  Promise.resolve(args)
.then(parseArguments)
.then((parsed) =&gt; {
  const check = checkProjectName(
    parsed.projectName,
    process.cwd(),
    fs.readdirSync('.')
  );
  const projectName = check.projectName;
  const dirName = check.dirName;
  const chdirTo = check.chdirTo;
  const createDir = check.createDir;
  maybeMakeDir(createDir, dirName);
  maybeChdir(chdirTo);

  // Before we create things, check if the directory is empty
  const dirWasPopulated = fs.readdirSync(process.cwd()).length !== 0;
  populateDir(projectName, dirWasPopulated, chdirTo, dirName);
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&gt; {
    white('Validating current schema version');
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&gt; checkForHzTables)
      .do(() =&gt; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&gt; green(' â””â”€â”€ Pre-2.0 schema found'))
      .catch((e) =&gt; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don't have a Horizon app in this database, or if \
you've already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.interrupt" id="apidoc.module.horizon.interrupt">module horizon.interrupt</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.interrupt.interrupt" id="apidoc.element.horizon.interrupt.interrupt">
        function <span class="apidocSignatureSpan">horizon.</span>interrupt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&gt; {
  process.removeAllListeners('SIGTERM');
  process.removeAllListeners('SIGINT');
  process.on('SIGTERM', () =&gt; process.exit(1));
  process.on('SIGINT', () =&gt; process.exit(1));

  return run_handlers();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.interrupt.on_interrupt" id="apidoc.element.horizon.interrupt.on_interrupt">
        function <span class="apidocSignatureSpan">horizon.interrupt.</span>on_interrupt
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(cb) =&gt; {
  handlers.push(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const start_rdb_server = require('./utils/start_rdb_server');
const NiceError = require('./utils/nice_error.js');

const VERSION_2_0 = [ 2, 0, 0 ];

function run(cmdArgs) {
const options = processConfig(cmdArgs);
interrupt.<span class="apidocCodeKeywordSpan">on_interrupt</span>(() =&gt; teardown());
return Promise.resolve().bind({ options })
  .then(setup)
  .then(validateMigration)
  .then(makeBackup)
  .then(renameUserTables)
  .then(moveInternalTables)
  .then(renameIndices)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.make_token" id="apidoc.module.horizon.make_token">module horizon.make_token</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.make_token.run" id="apidoc.element.horizon.make_token.run">
        function <span class="apidocSignatureSpan">horizon.make_token.</span>run
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&gt; Promise.resolve().then(() =&gt; {
  const options = processConfig(parseArguments(args));

  if (options.token_secret === null) {
    throw new Error('No token secret specified, unable to sign the token.');
  }
  const token = jwt.sign(
    { id: options.user, provider: null },
    new Buffer(options.token_secret, 'base64'),
    { expiresIn: '1d', algorithm: 'HS512' }
  );
  console.log(`${token}`);
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&gt; {
    white('Validating current schema version');
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&gt; checkForHzTables)
      .do(() =&gt; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&gt; green(' â””â”€â”€ Pre-2.0 schema found'))
      .catch((e) =&gt; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don't have a Horizon app in this database, or if \
you've already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.migrate" id="apidoc.module.horizon.migrate">module horizon.migrate</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.migrate.run" id="apidoc.element.horizon.migrate.run">
        function <span class="apidocSignatureSpan">horizon.migrate.</span>run
        <span class="apidocSignatureSpan">(cmdArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function run(cmdArgs) {
  const options = processConfig(cmdArgs);
  interrupt.on_interrupt(() =&gt; teardown());
  return Promise.resolve().bind({ options })
    .then(setup)
    .then(validateMigration)
    .then(makeBackup)
    .then(renameUserTables)
    .then(moveInternalTables)
    .then(renameIndices)
    .then(rewriteHzCollectionDocs)
    .then(exportNewSchema)
    .finally(teardown);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&gt; {
    white('Validating current schema version');
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&gt; checkForHzTables)
      .do(() =&gt; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&gt; green(' â””â”€â”€ Pre-2.0 schema found'))
      .catch((e) =&gt; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don't have a Horizon app in this database, or if \
you've already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.schema" id="apidoc.module.horizon.schema">module horizon.schema</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.schema.parse_schema" id="apidoc.element.horizon.schema.parse_schema">
        function <span class="apidocSignatureSpan">horizon.schema.</span>parse_schema
        <span class="apidocSignatureSpan">(schema_toml)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(schema_toml) =&gt; {
  const parsed = Joi.validate(toml.parse(schema_toml), schema_schema);
  const schema = parsed.value;

  if (parsed.error) {
    throw parsed.error;
  }

  const collections = [ ];
  for (const name in schema.collections) {
    collections.push({
      id: name,
      indexes: schema.collections[name].indexes.map((index) =&gt; {
        if (typeof index === 'string') {
          return { fields: v1_0_name_to_fields(index), multi: false, geo: false };
        } else {
          return { fields: index.fields, multi: false, geo: false };
        }
      }),
    });
  }

  // Make sure the 'users' collection is present, as some things depend on
  // its existence.
  if (!schema.collections || !schema.collections.users) {
    collections.push({ id: 'users', indexes: [ ] });
  }

  const groups = [ ];
  for (const name in schema.groups) {
    groups.push(Object.assign({ id: name }, schema.groups[name]));
  }

  return { groups, collections };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.schema.processApplyConfig" id="apidoc.element.horizon.schema.processApplyConfig">
        function <span class="apidocSignatureSpan">horizon.schema.</span>processApplyConfig
        <span class="apidocSignatureSpan">(parsed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(parsed) =&gt; {
  let options, in_file;

  options = config.default_options();
  options = config.merge_options(options,
    config.read_from_config_file(parsed.project_path));
  options = config.merge_options(options, config.read_from_env());
  options = config.merge_options(options, config.read_from_flags(parsed));

  if (parsed.schema_file === '-') {
    in_file = process.stdin;
  } else {
    in_file = fs.createReadStream(parsed.schema_file, { flags: 'r' });
  }

  if (options.project_name === null) {
    options.project_name = path.basename(path.resolve(options.project_path));
  }

  return {
    subcommand_name: 'apply',
    start_rethinkdb: options.start_rethinkdb,
    rdb_host: options.rdb_host,
    rdb_port: options.rdb_port,
    project_name: options.project_name,
    project_path: options.project_path,
    debug: options.debug,
    update: parse_yes_no_option(parsed.update),
    force: parse_yes_no_option(parsed.force),
    in_file,
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
try {
  fs.accessAsync(opts.schema_file, fs.R_OK | fs.F_OK);
} catch (e) {
  console.error(
    chalk.yellow.bold('No .hz/schema.toml file found'));
  return;
}
const schemaOptions = schema.<span class="apidocCodeKeywordSpan">processApplyConfig</span>({
  project_name: opts.project_name,
  schema_file: opts.schema_file,
  start_rethinkdb: false,
  connect: `${opts.rdb_host}:${opts.rdb_port}`,
  update: true,
  force: false,
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.schema.run" id="apidoc.element.horizon.schema.run">
        function <span class="apidocSignatureSpan">horizon.schema.</span>run
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&gt;
Promise.resolve().then(() =&gt; {
  const options = processConfig(parseArguments(args));
  // Determine if we are saving or applying and use appropriate run function
  switch (options.subcommand_name) {
  case 'apply':
    return runApplyCommand(options);
  case 'save':
    return runSaveCommand(options);
  default:
    throw new Error(`Unrecognized schema subcommand: "${options.subcommand_name}"`);
  }
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&gt; {
    white('Validating current schema version');
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&gt; checkForHzTables)
      .do(() =&gt; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&gt; green(' â””â”€â”€ Pre-2.0 schema found'))
      .catch((e) =&gt; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don't have a Horizon app in this database, or if \
you've already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.schema.runApplyCommand" id="apidoc.element.horizon.schema.runApplyCommand">
        function <span class="apidocSignatureSpan">horizon.schema.</span>runApplyCommand
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(options) =&gt; {
  let conn, schema, rdb_server;
  let obsolete_collections = [ ];
  const db = options.project_name;

  const cleanup = () =&gt;
    Promise.all([
      conn ? conn.close() : Promise.resolve(),
      rdb_server ? rdb_server.close() : Promise.resolve(),
    ]);

  interrupt.on_interrupt(() =&gt; cleanup());

  return Promise.resolve().then(() =&gt; {
    if (options.start_rethinkdb) {
      change_to_project_dir(options.project_path);
    }

    return new Promise((resolve, reject) =&gt; {
      let schema_toml = '';
      options.in_file.on('data', (buffer) =&gt; (schema_toml += buffer));
      options.in_file.on('end', () =&gt; resolve(schema_toml));
      options.in_file.on('error', reject);
    });
  }).then((schema_toml) =&gt; {
    schema = parse_schema(schema_toml);

    if (options.start_rethinkdb) {
      return start_rdb_server({ quiet: !options.debug }).then((server) =&gt; {
        rdb_server = server;
        options.rdb_host = 'localhost';
        options.rdb_port = server.driver_port;
      });
    }
  }).then(() =&gt;
    r.connect({ host: options.rdb_host,
                port: options.rdb_port,
                user: options.rdb_user,
                password: options.rdb_password,
                timeout: options.rdb_timeout })
  ).then((rdb_conn) =&gt; {
    conn = rdb_conn;
    return initialize_metadata(db, conn);
  }).then((initialization_result) =&gt; {
    if (initialization_result.tables_created) {
      console.log('Initialized new application metadata.');
    }
    // Wait for metadata tables to be writable
    return r.expr([ 'hz_collections', 'hz_groups' ])
      .forEach((table) =&gt;
        r.db(db).table(table)
          .wait({ waitFor: 'ready_for_writes', timeout: 30 }))
      .run(conn);
  }).then(() =&gt; {
    // Error if any collections will be removed
    if (!options.update) {
      return r.db(db).table('hz_collections')
        .filter((row) =&gt; row('id').match('^hz_').not())
        .getField('id')
        .coerceTo('array')
        .setDifference(schema.collections.map((c) =&gt; c.id))
        .run(conn)
        .then((res) =&gt; {
          if (!options.force &amp;&amp; res.length &gt; 0) {
            throw new Error('Run with "--force" to continue.\n' +
                            'These collections would be removed along with their data:\n' +
                            `${res.join(', ')}`);
          }
          obsolete_collections = res;
        });
    }
  }).then(() =&gt; {
    if (options.update) {
      // Update groups
      return Promise.all(schema.groups.map((group) =&gt; {
        const literal_group = JSON.parse(JSON.stringify(group));
        Object.keys(literal_group.rules).forEach((key) =&gt; {
          literal_group.rules[key] = r.literal(literal_group.rules[key]);
        });

        return r.db(db).table('hz_groups')
          .get(group.id).replace((old_row) =&gt;
            r.branch(old_row.eq(null),
                     group,
                     old_row.merge(literal_group)))
          .run(conn).then((res) =&gt; {
            if (res.errors) {
              throw new Error(`Failed to update group: ${res.first_error}`);
            }
          });
      }));
    } else {
      // Replace and remove groups
      const groups_obj = { };
      schema.groups.forEach((g) =&gt; { groups_obj[g.id] = g; });

      return Promise.all([
        r.expr(groups_obj).do((groups) =&gt;
          r.db(db).table('hz_groups')
            .replace((old_row) =&gt;
              r.branch(groups.hasFields(old_row('id')),
                       old_row,
                       null))
          ).run(conn).then((res) =&gt; {
            if (res.errors) {
              throw new Error(`Failed to write groups: ${res.first_error}`);
            }
          }),
        r.db(db).table('hz_groups')
          .insert(schema.groups, { conflict: 'replace' })
          .run(conn).then((res) =&gt; {
            if (res.errors) {
              throw new Error(`Failed to write groups: ${res.first_error}`);
            }
          }),
      ]);
    }
  }).then(() =&gt; {
    // Ensure all collections exist and remove any obsolete collections
    const promise ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    project_name: opts.project_name,
    schema_file: opts.schema_file,
    start_rethinkdb: false,
    connect: `${opts.rdb_host}:${opts.rdb_port}`,
    update: true,
    force: false,
  });
  return schema.<span class="apidocCodeKeywordSpan">runApplyCommand</span>(schemaOptions);
}
  }).then(() =&gt; {
console.log('Starting Horizon...');
hz_server = start_horizon_server(http_servers, opts);

return new Promise((resolve, reject) =&gt; {
  const timeoutObject = setTimeout(() =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.schema.runSaveCommand" id="apidoc.element.horizon.schema.runSaveCommand">
        function <span class="apidocSignatureSpan">horizon.schema.</span>runSaveCommand
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(options) =&gt; {
  let conn, rdb_server;
  const db = options.project_name;

  const cleanup = () =&gt;
    Promise.all([
      conn ? conn.close() : Promise.resolve(),
      rdb_server ? rdb_server.close() : Promise.resolve(),
    ]);

  interrupt.on_interrupt(() =&gt; cleanup());

  return Promise.resolve().then(() =&gt; {
    if (options.start_rethinkdb) {
      change_to_project_dir(options.project_path);
    }
  }).then(() =&gt; {
    if (options.start_rethinkdb) {
      return start_rdb_server({ quiet: !options.debug }).then((server) =&gt; {
        rdb_server = server;
        options.rdb_host = 'localhost';
        options.rdb_port = server.driver_port;
      });
    }
  }).then(() =&gt;
    r.connect({ host: options.rdb_host,
                port: options.rdb_port,
                user: options.rdb_user,
                password: options.rdb_password,
                timeout: options.rdb_timeout })
  ).then((rdb_conn) =&gt; {
    conn = rdb_conn;
    return r.db(db).wait({ waitFor: 'ready_for_reads', timeout: 30 }).run(conn);
  }).then(() =&gt;
    r.object('collections',
             r.db(db).table('hz_collections')
               .filter((row) =&gt; row('id').match('^hz_').not())
               .coerceTo('array')
               .map((row) =&gt;
                 row.merge({ indexes: r.db(db).table(row('id')).indexList() })),
             'groups', r.db(db).table('hz_groups').coerceTo('array'))
      .run(conn)
  ).then((res) =&gt;
    new Promise((resolve) =&gt; {
      // Only rename old file if saving to default .hz/schema.toml
      if (options.out_file === '.hz/schema.toml' &amp;&amp;
          file_exists(options.out_file)) {
        // Rename existing file to have the current time appended to its name
        const oldPath = path.resolve(options.out_file);
        const newPath = `${path.resolve(options.out_file)}.${new Date().toISOString()}`;
        fs.renameSync(oldPath, newPath);
      }

      const output = (options.out_file === '-') ? process.stdout :
        fs.createWriteStream(options.out_file, { flags: 'w', defaultEncoding: 'utf8' });

      // Output toml_str to schema.toml
      const toml_str = schema_to_toml(res.collections, res.groups);
      output.end(toml_str, resolve);
    })
  ).then(cleanup).catch((err) =&gt; cleanup().then(() =&gt; { throw err; }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.serve" id="apidoc.module.horizon.serve">module horizon.serve</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.serve.parseArguments" id="apidoc.element.horizon.serve.parseArguments">
        function <span class="apidocSignatureSpan">horizon.serve.</span>parseArguments
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&gt; {
  const parser = new argparse.ArgumentParser({ prog: 'hz serve' });

  parser.addArgument([ 'project_path' ],
    { type: 'string', nargs: '?',
      help: 'Change to this directory before serving' });

  parser.addArgument([ '--project-name', '-n' ],
    { type: 'string', action: 'store', metavar: 'NAME',
      help: 'Name of the Horizon project. Determines the name of ' +
            'the RethinkDB database that stores the project data.' });

  parser.addArgument([ '--bind', '-b' ],
    { type: 'string', action: 'append', metavar: 'HOST',
      help: 'Local hostname to serve horizon on (repeatable).' });

  parser.addArgument([ '--port', '-p' ],
    { type: 'int', metavar: 'PORT',
      help: 'Local port to serve horizon on.' });

  parser.addArgument([ '--connect', '-c' ],
    { type: 'string', metavar: 'HOST:PORT',
      help: 'Host and port of the RethinkDB server to connect to.' });

  parser.addArgument([ '--rdb-timeout' ],
    { type: 'int', metavar: 'TIMEOUT',
      help: 'Timeout period in seconds for the RethinkDB connection to be opened' });

  parser.addArgument([ '--rdb-user' ],
    { type: 'string', metavar: 'USER',
      help: 'RethinkDB User' });

  parser.addArgument([ '--rdb-password' ],
    { type: 'string', metavar: 'PASSWORD',
      help: 'RethinkDB Password' });

  parser.addArgument([ '--key-file' ],
    { type: 'string', metavar: 'PATH',
      help: 'Path to the key file to use, defaults to "./horizon-key.pem".' });

  parser.addArgument([ '--cert-file' ],
    { type: 'string', metavar: 'PATH',
      help: 'Path to the cert file to use, defaults to "./horizon-cert.pem".' });

  parser.addArgument([ '--token-secret' ],
    { type: 'string', metavar: 'SECRET',
      help: 'Key for signing jwts' });

  parser.addArgument([ '--allow-unauthenticated' ],
    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',
      help: 'Whether to allow unauthenticated Horizon connections.' });

  parser.addArgument([ '--allow-anonymous' ],
    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',
      help: 'Whether to allow anonymous Horizon connections.' });

  parser.addArgument([ '--debug' ],
    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',
      help: 'Enable debug logging.' });

  parser.addArgument([ '--secure' ],
    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',
      help: 'Serve secure websockets, requires --key-file and ' +
      '--cert-file if true, on by default.' });

  parser.addArgument([ '--start-rethinkdb' ],
    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',
      help: 'Start up a RethinkDB server in the current directory' });

  parser.addArgument([ '--auto-create-collection' ],
    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',
      help: 'Create collections used by requests if they do not exist.' });

  parser.addArgument([ '--auto-create-index' ],
    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',
      help: 'Create indexes used by requests if they do not exist.' });

  parser.addArgument([ '--permissions' ],
    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',
      help: 'Enables or disables checking permissions on requests.' });

  parser.addArgument([ '--serve-static' ],
    { type: 'string', metavar: 'PATH', nargs: '?', constant: './dist',
      help: 'Serve static files from a directory, defaults to "./dist".' });

  parser.addArgument([ '--dev' ],
    { action: 'storeTrue',
      help: 'Runs the server in development mode, this sets ' +
      '--secure=no, ' +
      '--permissions=no, ' +
      '--auto-create-collection=yes, ' +
      '--auto-create-index=yes, ' +
      '--start-rethinkdb=yes, ' +
      '--allow-unauthenticated=yes, ' +
      '--allow-anonymous=yes ' +
      'and --serve-static=./dist.' });

  parser.addArgument([ '--schema-file' ],
    { type: 'string', metavar: 'SCHEMA_FILE_PATH',
      help: 'Path to the schema file to use, ' +
      'will attempt to apply schema before starting Horizon server".' });

  parser.a ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.serve.processConfig" id="apidoc.element.horizon.serve.processConfig">
        function <span class="apidocSignatureSpan">horizon.serve.</span>processConfig
        <span class="apidocSignatureSpan">(parsed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(parsed) =&gt; {
  let options;

  options = config.default_options();

  options = config.merge_options(options,
    config.read_from_config_file(parsed.project_path));

  options = config.merge_options(options,
    config.read_from_secrets_file(parsed.project_path));

  options = config.merge_options(options, config.read_from_env());

  options = config.merge_options(options, config.read_from_flags(parsed));

  if (options.project_name === null) {
    options.project_name = path.basename(path.resolve(options.project_path));
  }

  if (options.bind.indexOf('all') !== -1) {
    options.bind = [ '0.0.0.0' ];
  }

  if (!options.rdb_host) {
    options.rdb_host = default_rdb_host;
  }

  if (!options.rdb_port) {
    options.rdb_port = default_rdb_port;
  }

  if (!options.rdb_timeout) {
    options.rdb_timeout = default_rdb_timeout;
  }

  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.serve.run" id="apidoc.element.horizon.serve.run">
        function <span class="apidocSignatureSpan">horizon.serve.</span>run
        <span class="apidocSignatureSpan">(args, interruptor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args, interruptor) =&gt; {
  let opts, http_servers, hz_server, rdb_server;
  const old_log_level = logger.level;

  const cleanup = () =&gt; {
    logger.level = old_log_level;

    return Promise.all([
      hz_server ? hz_server.close() : Promise.resolve(),
      rdb_server ? rdb_server.close() : Promise.resolve(),
      http_servers ? Promise.all(http_servers.map((s) =&gt;
        new Promise((resolve) =&gt; s.close(resolve)))) : Promise.resolve(),
    ]);
  };

  interrupt.on_interrupt(() =&gt; cleanup());

  return Promise.resolve().then(() =&gt; {
    opts = processConfig(parseArguments(args));
    logger.level = opts.debug ? 'debug' : 'warn';

    if (!opts.secure &amp;&amp; opts.auth &amp;&amp; Array.from(Object.keys(opts.auth)).length &gt; 0) {
      logger.warn('Authentication requires that the server be accessible via HTTPS. ' +
                  'Either specify "secure=true" or use a reverse proxy.');
    }

    change_to_project_dir(opts.project_path);

    if (opts.secure) {
      return create_secure_servers(opts);
    } else {
      return create_insecure_servers(opts);
    }
  }).then((servers) =&gt; {
    http_servers = servers;

    if (opts.start_rethinkdb) {
      return start_rdb_server().then((server) =&gt; {
        rdb_server = server;

        // Don't need to check for host, always localhost.
        opts.rdb_host = 'localhost';
        opts.rdb_port = server.driver_port;

        console.log('RethinkDB');
        console.log(`   â”œâ”€â”€ Admin interface: http://localhost:${server.http_port}`);
        console.log(`   â””â”€â”€ Drivers can connect to port ${server.driver_port}`);
      });
    }
  }).then(() =&gt; {
    // Ensure schema from schema.toml file is set
    if (opts.schema_file) {
      console.log(`Ensuring schema "${opts.schema_file}" is applied`);
      try {
        fs.accessAsync(opts.schema_file, fs.R_OK | fs.F_OK);
      } catch (e) {
        console.error(
          chalk.yellow.bold('No .hz/schema.toml file found'));
        return;
      }
      const schemaOptions = schema.processApplyConfig({
        project_name: opts.project_name,
        schema_file: opts.schema_file,
        start_rethinkdb: false,
        connect: `${opts.rdb_host}:${opts.rdb_port}`,
        update: true,
        force: false,
      });
      return schema.runApplyCommand(schemaOptions);
    }
  }).then(() =&gt; {
    console.log('Starting Horizon...');
    hz_server = start_horizon_server(http_servers, opts);

    return new Promise((resolve, reject) =&gt; {
      const timeoutObject = setTimeout(() =&gt; {
        reject(new Error('Horizon failed to start after 30 seconds.\n' +
                         'Try running hz serve again with the --debug flag'));
      }, TIMEOUT_30_SECONDS);

      hz_server.ready().then(() =&gt; {
        clearTimeout(timeoutObject);
        console.log(chalk.green.bold('ðŸŒ„ Horizon ready for connections'));
        resolve(hz_server);
      }).catch(reject);
    });
  }).then(() =&gt; {
    if (opts.auth) {
      for (const name in opts.auth) {
        const provider = horizon_server.auth[name];
        if (!provider) {
          throw new Error(`Unrecognized auth provider "${name}"`);
        }
        hz_server.add_auth_provider(provider,
                                    Object.assign({}, { path: name }, opts.auth[name]));
      }
    }
  }).then(() =&gt; {
    // Automatically open up index.html in the `dist` directory only if
    //  `--open` flag specified and an index.html exists in the directory.
    if (opts.open &amp;&amp; opts.serve_static) {
      try {
        // Check if index.html exists and readable in serve static_static directory
        fs.accessSync(`${opts.serve_static}/index.html`, fs.R_OK | fs.F_OK);
        // Determine scheme from options
        const scheme = opts.secure ? 'https://' : 'http://';
        // Open up index.html in default browser
        console.log('Attempting open of index.html in default browser');
        open(`${scheme}${opts.bind}:${opts.port}/index.html`);
      } catch (open_err) {
        console.log(chalk.red('Error occurred while trying to open ' +
                              `${opts.serve_sta ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&gt; {
    white('Validating current schema version');
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&gt; checkForHzTables)
      .do(() =&gt; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&gt; green(' â””â”€â”€ Pre-2.0 schema found'))
      .catch((e) =&gt; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don't have a Horizon app in this database, or if \
you've already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.start_rdb_server" id="apidoc.module.horizon.start_rdb_server">module horizon.start_rdb_server</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.start_rdb_server.start_rdb_server" id="apidoc.element.horizon.start_rdb_server.start_rdb_server">
        function <span class="apidocSignatureSpan">horizon.</span>start_rdb_server
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(options) =&gt; new RethinkdbServer(options || { }).ready()</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.start_rdb_server.r" id="apidoc.element.horizon.start_rdb_server.r">
        function <span class="apidocSignatureSpan">horizon.start_rdb_server.</span>r
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">r = function () {
  var args;
  args = 1 &lt;= arguments.length ? slice.call(arguments, 0) : [];
  return rethinkdb.expr.apply(rethinkdb, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.version" id="apidoc.module.horizon.version">module horizon.version</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.version.run" id="apidoc.element.horizon.version.run">
        function <span class="apidocSignatureSpan">horizon.version.</span>run
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&gt;
Promise.resolve().then(() =&gt; {
  if (args &amp;&amp; args.length) {
    throw new Error('create-cert takes no arguments');
  }
  console.info(package_json.version);
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&gt; {
    white('Validating current schema version');
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&gt; checkForHzTables)
      .do(() =&gt; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&gt; green(' â””â”€â”€ Pre-2.0 schema found'))
      .catch((e) =&gt; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don't have a Horizon app in this database, or if \
you've already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>