<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/rethinkdb/horizon#readme">horizon (v2.0.0)</a>
</h1>
<h4>An open-source developer platform for building realtime, scalable web apps.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon">module horizon</a><ol>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>create_cert</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>init</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>make_token</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>migrate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>schema</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>serve</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">horizon.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.create_cert">module horizon.create_cert</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.create_cert.run">
            function <span class="apidocSignatureSpan">horizon.create_cert.</span>run
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.create_cert.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.init">module horizon.init</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.init.run">
            function <span class="apidocSignatureSpan">horizon.init.</span>run
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.init.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.make_token">module horizon.make_token</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.make_token.run">
            function <span class="apidocSignatureSpan">horizon.make_token.</span>run
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.make_token.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.migrate">module horizon.migrate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.migrate.run">
            function <span class="apidocSignatureSpan">horizon.migrate.</span>run
            <span class="apidocSignatureSpan">(cmdArgs)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.migrate.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.schema">module horizon.schema</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.schema.parse_schema">
            function <span class="apidocSignatureSpan">horizon.schema.</span>parse_schema
            <span class="apidocSignatureSpan">(schema_toml)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.schema.processApplyConfig">
            function <span class="apidocSignatureSpan">horizon.schema.</span>processApplyConfig
            <span class="apidocSignatureSpan">(parsed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.schema.run">
            function <span class="apidocSignatureSpan">horizon.schema.</span>run
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.schema.runApplyCommand">
            function <span class="apidocSignatureSpan">horizon.schema.</span>runApplyCommand
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.schema.runSaveCommand">
            function <span class="apidocSignatureSpan">horizon.schema.</span>runSaveCommand
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.schema.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.serve">module horizon.serve</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.serve.parseArguments">
            function <span class="apidocSignatureSpan">horizon.serve.</span>parseArguments
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.serve.processConfig">
            function <span class="apidocSignatureSpan">horizon.serve.</span>processConfig
            <span class="apidocSignatureSpan">(parsed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.serve.run">
            function <span class="apidocSignatureSpan">horizon.serve.</span>run
            <span class="apidocSignatureSpan">(args, interruptor)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.serve.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.horizon.version">module horizon.version</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.horizon.version.run">
            function <span class="apidocSignatureSpan">horizon.version.</span>run
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">horizon.version.</span>description</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon" id="apidoc.module.horizon">module horizon</a></h1>















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.create_cert" id="apidoc.module.horizon.create_cert">module horizon.create_cert</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.create_cert.run" id="apidoc.element.horizon.create_cert.run">
        function <span class="apidocSignatureSpan">horizon.create_cert.</span>run
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&gt; {
  if (args.length) {
    throw new Error('create-cert takes no arguments');
  }

  // TODO: user configuration?
  const settings = {
    binaryName: 'openssl',
    keyOutName: 'horizon-key.pem',
    certOutName: 'horizon-cert.pem',
    algo: 'rsa',
    bits: '2048',
    days: '365',
  };

  // generate the arguments to the command
  const binArgs = [ 'req', '-x509', '-nodes', '-batch',
    '-newkey', `${settings.algo}:${settings.bits}`,
    '-keyout', settings.keyOutName,
    '-out', settings.certOutName,
    '-days', settings.days,
  ];

  return new Promise((resolve, reject) =&gt; {
    hasbin(settings.binaryName, (hasOpenSSL) =&gt; {
      // show the invocation that's about to be run
      console.log(`&gt; ${settings.binaryName} ${binArgs.join(' ')}`);

      // if we don't have openssl, bail
      if (!hasOpenSSL) {
        reject(new Error(`Missing ${settings.binaryName}. Make sure it is on the path.`));
      }

      // otherwise start openssl
      const sslProc = spawn(settings.binaryName, binArgs);

      // pipe output appropriately
      sslProc.stdout.pipe(process.stdout, { end: false });
      sslProc.stderr.pipe(process.stderr, { end: false });

      // say nice things to the user when it's done
      sslProc.on('error', reject);
      sslProc.on('close', (code) =&gt; {
        if (code) {
          reject(new Error(`OpenSSL failed with code ${code}.`));
        } else {
          console.log('Everything seems to be fine. ' +
                      'Remember to add your shiny new certificates to your Horizon config!');
          resolve();
        }
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&gt; {
    white('Validating current schema version');
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&gt; checkForHzTables)
      .do(() =&gt; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&gt; green(' â””â”€â”€ Pre-2.0 schema found'))
      .catch((e) =&gt; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don't have a Horizon app in this database, or if \
you've already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.init" id="apidoc.module.horizon.init">module horizon.init</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.init.run" id="apidoc.element.horizon.init.run">
        function <span class="apidocSignatureSpan">horizon.init.</span>run
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&gt;
  Promise.resolve(args)
.then(parseArguments)
.then((parsed) =&gt; {
  const check = checkProjectName(
    parsed.projectName,
    process.cwd(),
    fs.readdirSync('.')
  );
  const projectName = check.projectName;
  const dirName = check.dirName;
  const chdirTo = check.chdirTo;
  const createDir = check.createDir;
  maybeMakeDir(createDir, dirName);
  maybeChdir(chdirTo);

  // Before we create things, check if the directory is empty
  const dirWasPopulated = fs.readdirSync(process.cwd()).length !== 0;
  populateDir(projectName, dirWasPopulated, chdirTo, dirName);
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&gt; {
    white('Validating current schema version');
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&gt; checkForHzTables)
      .do(() =&gt; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&gt; green(' â””â”€â”€ Pre-2.0 schema found'))
      .catch((e) =&gt; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don't have a Horizon app in this database, or if \
you've already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.make_token" id="apidoc.module.horizon.make_token">module horizon.make_token</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.make_token.run" id="apidoc.element.horizon.make_token.run">
        function <span class="apidocSignatureSpan">horizon.make_token.</span>run
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&gt; Promise.resolve().then(() =&gt; {
  const options = processConfig(parseArguments(args));

  if (options.token_secret === null) {
    throw new Error('No token secret specified, unable to sign the token.');
  }
  const token = jwt.sign(
    { id: options.user, provider: null },
    new Buffer(options.token_secret, 'base64'),
    { expiresIn: '1d', algorithm: 'HS512' }
  );
  console.log(`${token}`);
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&gt; {
    white('Validating current schema version');
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&gt; checkForHzTables)
      .do(() =&gt; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&gt; green(' â””â”€â”€ Pre-2.0 schema found'))
      .catch((e) =&gt; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don't have a Horizon app in this database, or if \
you've already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.migrate" id="apidoc.module.horizon.migrate">module horizon.migrate</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.migrate.run" id="apidoc.element.horizon.migrate.run">
        function <span class="apidocSignatureSpan">horizon.migrate.</span>run
        <span class="apidocSignatureSpan">(cmdArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function run(cmdArgs) {
  const options = processConfig(cmdArgs);
  interrupt.on_interrupt(() =&gt; teardown());
  return Promise.resolve().bind({ options })
    .then(setup)
    .then(validateMigration)
    .then(makeBackup)
    .then(renameUserTables)
    .then(moveInternalTables)
    .then(renameIndices)
    .then(rewriteHzCollectionDocs)
    .then(exportNewSchema)
    .finally(teardown);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&gt; {
    white('Validating current schema version');
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&gt; checkForHzTables)
      .do(() =&gt; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&gt; green(' â””â”€â”€ Pre-2.0 schema found'))
      .catch((e) =&gt; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don't have a Horizon app in this database, or if \
you've already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.schema" id="apidoc.module.horizon.schema">module horizon.schema</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.schema.parse_schema" id="apidoc.element.horizon.schema.parse_schema">
        function <span class="apidocSignatureSpan">horizon.schema.</span>parse_schema
        <span class="apidocSignatureSpan">(schema_toml)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(schema_toml) =&gt; {
  const parsed = Joi.validate(toml.parse(schema_toml), schema_schema);
  const schema = parsed.value;

  if (parsed.error) {
    throw parsed.error;
  }

  const collections = [ ];
  for (const name in schema.collections) {
    collections.push({
      id: name,
      indexes: schema.collections[name].indexes.map((index) =&gt; {
        if (typeof index === 'string') {
          return { fields: v1_0_name_to_fields(index), multi: false, geo: false };
        } else {
          return { fields: index.fields, multi: false, geo: false };
        }
      }),
    });
  }

  // Make sure the 'users' collection is present, as some things depend on
  // its existence.
  if (!schema.collections || !schema.collections.users) {
    collections.push({ id: 'users', indexes: [ ] });
  }

  const groups = [ ];
  for (const name in schema.groups) {
    groups.push(Object.assign({ id: name }, schema.groups[name]));
  }

  return { groups, collections };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.schema.processApplyConfig" id="apidoc.element.horizon.schema.processApplyConfig">
        function <span class="apidocSignatureSpan">horizon.schema.</span>processApplyConfig
        <span class="apidocSignatureSpan">(parsed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(parsed) =&gt; {
  let options, in_file;

  options = config.default_options();
  options = config.merge_options(options,
    config.read_from_config_file(parsed.project_path));
  options = config.merge_options(options, config.read_from_env());
  options = config.merge_options(options, config.read_from_flags(parsed));

  if (parsed.schema_file === '-') {
    in_file = process.stdin;
  } else {
    in_file = fs.createReadStream(parsed.schema_file, { flags: 'r' });
  }

  if (options.project_name === null) {
    options.project_name = path.basename(path.resolve(options.project_path));
  }

  return {
    subcommand_name: 'apply',
    start_rethinkdb: options.start_rethinkdb,
    rdb_host: options.rdb_host,
    rdb_port: options.rdb_port,
    project_name: options.project_name,
    project_path: options.project_path,
    debug: options.debug,
    update: parse_yes_no_option(parsed.update),
    force: parse_yes_no_option(parsed.force),
    in_file,
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
try {
  fs.accessAsync(opts.schema_file, fs.R_OK | fs.F_OK);
} catch (e) {
  console.error(
    chalk.yellow.bold('No .hz/schema.toml file found'));
  return;
}
const schemaOptions = schema.<span class="apidocCodeKeywordSpan">processApplyConfig</span>({
  project_name: opts.project_name,
  schema_file: opts.schema_file,
  start_rethinkdb: false,
  connect: `${opts.rdb_host}:${opts.rdb_port}`,
  update: true,
  force: false,
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.schema.run" id="apidoc.element.horizon.schema.run">
        function <span class="apidocSignatureSpan">horizon.schema.</span>run
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&gt;
Promise.resolve().then(() =&gt; {
  const options = processConfig(parseArguments(args));
  // Determine if we are saving or applying and use appropriate run function
  switch (options.subcommand_name) {
  case 'apply':
    return runApplyCommand(options);
  case 'save':
    return runSaveCommand(options);
  default:
    throw new Error(`Unrecognized schema subcommand: "${options.subcommand_name}"`);
  }
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&gt; {
    white('Validating current schema version');
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&gt; checkForHzTables)
      .do(() =&gt; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&gt; green(' â””â”€â”€ Pre-2.0 schema found'))
      .catch((e) =&gt; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don't have a Horizon app in this database, or if \
you've already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.schema.runApplyCommand" id="apidoc.element.horizon.schema.runApplyCommand">
        function <span class="apidocSignatureSpan">horizon.schema.</span>runApplyCommand
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(options) =&gt; {
  let conn, schema, rdb_server;
  let obsolete_collections = [ ];
  const db = options.project_name;

  const cleanup = () =&gt;
    Promise.all([
      conn ? conn.close() : Promise.resolve(),
      rdb_server ? rdb_server.close() : Promise.resolve(),
    ]);

  interrupt.on_interrupt(() =&gt; cleanup());

  return Promise.resolve().then(() =&gt; {
    if (options.start_rethinkdb) {
      change_to_project_dir(options.project_path);
    }

    return new Promise((resolve, reject) =&gt; {
      let schema_toml = '';
      options.in_file.on('data', (buffer) =&gt; (schema_toml += buffer));
      options.in_file.on('end', () =&gt; resolve(schema_toml));
      options.in_file.on('error', reject);
    });
  }).then((schema_toml) =&gt; {
    schema = parse_schema(schema_toml);

    if (options.start_rethinkdb) {
      return start_rdb_server({ quiet: !options.debug }).then((server) =&gt; {
        rdb_server = server;
        options.rdb_host = 'localhost';
        options.rdb_port = server.driver_port;
      });
    }
  }).then(() =&gt;
    r.connect({ host: options.rdb_host,
                port: options.rdb_port,
                user: options.rdb_user,
                password: options.rdb_password,
                timeout: options.rdb_timeout })
  ).then((rdb_conn) =&gt; {
    conn = rdb_conn;
    return initialize_metadata(db, conn);
  }).then((initialization_result) =&gt; {
    if (initialization_result.tables_created) {
      console.log('Initialized new application metadata.');
    }
    // Wait for metadata tables to be writable
    return r.expr([ 'hz_collections', 'hz_groups' ])
      .forEach((table) =&gt;
        r.db(db).table(table)
          .wait({ waitFor: 'ready_for_writes', timeout: 30 }))
      .run(conn);
  }).then(() =&gt; {
    // Error if any collections will be removed
    if (!options.update) {
      return r.db(db).table('hz_collections')
        .filter((row) =&gt; row('id').match('^hz_').not())
        .getField('id')
        .coerceTo('array')
        .setDifference(schema.collections.map((c) =&gt; c.id))
        .run(conn)
        .then((res) =&gt; {
          if (!options.force &amp;&amp; res.length &gt; 0) {
            throw new Error('Run with "--force" to continue.\n' +
                            'These collections would be removed along with their data:\n' +
                            `${res.join(', ')}`);
          }
          obsolete_collections = res;
        });
    }
  }).then(() =&gt; {
    if (options.update) {
      // Update groups
      return Promise.all(schema.groups.map((group) =&gt; {
        const literal_group = JSON.parse(JSON.stringify(group));
        Object.keys(literal_group.rules).forEach((key) =&gt; {
          literal_group.rules[key] = r.literal(literal_group.rules[key]);
        });

        return r.db(db).table('hz_groups')
          .get(group.id).replace((old_row) =&gt;
            r.branch(old_row.eq(null),
                     group,
                     old_row.merge(literal_group)))
          .run(conn).then((res) =&gt; {
            if (res.errors) {
              throw new Error(`Failed to update group: ${res.first_error}`);
            }
          });
      }));
    } else {
      // Replace and remove groups
      const groups_obj = { };
      schema.groups.forEach((g) =&gt; { groups_obj[g.id] = g; });

      return Promise.all([
        r.expr(groups_obj).do((groups) =&gt;
          r.db(db).table('hz_groups')
            .replace((old_row) =&gt;
              r.branch(groups.hasFields(old_row('id')),
                       old_row,
                       null))
          ).run(conn).then((res) =&gt; {
            if (res.errors) {
              throw new Error(`Failed to write groups: ${res.first_error}`);
            }
          }),
        r.db(db).table('hz_groups')
          .insert(schema.groups, { conflict: 'replace' })
          .run(conn).then((res) =&gt; {
            if (res.errors) {
              throw new Error(`Failed to write groups: ${res.first_error}`);
            }
          }),
      ]);
    }
  }).then(() =&gt; {
    // Ensure all collections exist and remove any obsolete collections
    const promise ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    project_name: opts.project_name,
    schema_file: opts.schema_file,
    start_rethinkdb: false,
    connect: `${opts.rdb_host}:${opts.rdb_port}`,
    update: true,
    force: false,
  });
  return schema.<span class="apidocCodeKeywordSpan">runApplyCommand</span>(schemaOptions);
}
  }).then(() =&gt; {
console.log('Starting Horizon...');
hz_server = start_horizon_server(http_servers, opts);

return new Promise((resolve, reject) =&gt; {
  const timeoutObject = setTimeout(() =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.schema.runSaveCommand" id="apidoc.element.horizon.schema.runSaveCommand">
        function <span class="apidocSignatureSpan">horizon.schema.</span>runSaveCommand
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(options) =&gt; {
  let conn, rdb_server;
  const db = options.project_name;

  const cleanup = () =&gt;
    Promise.all([
      conn ? conn.close() : Promise.resolve(),
      rdb_server ? rdb_server.close() : Promise.resolve(),
    ]);

  interrupt.on_interrupt(() =&gt; cleanup());

  return Promise.resolve().then(() =&gt; {
    if (options.start_rethinkdb) {
      change_to_project_dir(options.project_path);
    }
  }).then(() =&gt; {
    if (options.start_rethinkdb) {
      return start_rdb_server({ quiet: !options.debug }).then((server) =&gt; {
        rdb_server = server;
        options.rdb_host = 'localhost';
        options.rdb_port = server.driver_port;
      });
    }
  }).then(() =&gt;
    r.connect({ host: options.rdb_host,
                port: options.rdb_port,
                user: options.rdb_user,
                password: options.rdb_password,
                timeout: options.rdb_timeout })
  ).then((rdb_conn) =&gt; {
    conn = rdb_conn;
    return r.db(db).wait({ waitFor: 'ready_for_reads', timeout: 30 }).run(conn);
  }).then(() =&gt;
    r.object('collections',
             r.db(db).table('hz_collections')
               .filter((row) =&gt; row('id').match('^hz_').not())
               .coerceTo('array')
               .map((row) =&gt;
                 row.merge({ indexes: r.db(db).table(row('id')).indexList() })),
             'groups', r.db(db).table('hz_groups').coerceTo('array'))
      .run(conn)
  ).then((res) =&gt;
    new Promise((resolve) =&gt; {
      // Only rename old file if saving to default .hz/schema.toml
      if (options.out_file === '.hz/schema.toml' &amp;&amp;
          file_exists(options.out_file)) {
        // Rename existing file to have the current time appended to its name
        const oldPath = path.resolve(options.out_file);
        const newPath = `${path.resolve(options.out_file)}.${new Date().toISOString()}`;
        fs.renameSync(oldPath, newPath);
      }

      const output = (options.out_file === '-') ? process.stdout :
        fs.createWriteStream(options.out_file, { flags: 'w', defaultEncoding: 'utf8' });

      // Output toml_str to schema.toml
      const toml_str = schema_to_toml(res.collections, res.groups);
      output.end(toml_str, resolve);
    })
  ).then(cleanup).catch((err) =&gt; cleanup().then(() =&gt; { throw err; }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.serve" id="apidoc.module.horizon.serve">module horizon.serve</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.serve.parseArguments" id="apidoc.element.horizon.serve.parseArguments">
        function <span class="apidocSignatureSpan">horizon.serve.</span>parseArguments
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&gt; {
  const parser = new argparse.ArgumentParser({ prog: 'hz serve' });

  parser.addArgument([ 'project_path' ],
    { type: 'string', nargs: '?',
      help: 'Change to this directory before serving' });

  parser.addArgument([ '--project-name', '-n' ],
    { type: 'string', action: 'store', metavar: 'NAME',
      help: 'Name of the Horizon project. Determines the name of ' +
            'the RethinkDB database that stores the project data.' });

  parser.addArgument([ '--bind', '-b' ],
    { type: 'string', action: 'append', metavar: 'HOST',
      help: 'Local hostname to serve horizon on (repeatable).' });

  parser.addArgument([ '--port', '-p' ],
    { type: 'int', metavar: 'PORT',
      help: 'Local port to serve horizon on.' });

  parser.addArgument([ '--connect', '-c' ],
    { type: 'string', metavar: 'HOST:PORT',
      help: 'Host and port of the RethinkDB server to connect to.' });

  parser.addArgument([ '--rdb-timeout' ],
    { type: 'int', metavar: 'TIMEOUT',
      help: 'Timeout period in seconds for the RethinkDB connection to be opened' });

  parser.addArgument([ '--rdb-user' ],
    { type: 'string', metavar: 'USER',
      help: 'RethinkDB User' });

  parser.addArgument([ '--rdb-password' ],
    { type: 'string', metavar: 'PASSWORD',
      help: 'RethinkDB Password' });

  parser.addArgument([ '--key-file' ],
    { type: 'string', metavar: 'PATH',
      help: 'Path to the key file to use, defaults to "./horizon-key.pem".' });

  parser.addArgument([ '--cert-file' ],
    { type: 'string', metavar: 'PATH',
      help: 'Path to the cert file to use, defaults to "./horizon-cert.pem".' });

  parser.addArgument([ '--token-secret' ],
    { type: 'string', metavar: 'SECRET',
      help: 'Key for signing jwts' });

  parser.addArgument([ '--allow-unauthenticated' ],
    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',
      help: 'Whether to allow unauthenticated Horizon connections.' });

  parser.addArgument([ '--allow-anonymous' ],
    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',
      help: 'Whether to allow anonymous Horizon connections.' });

  parser.addArgument([ '--debug' ],
    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',
      help: 'Enable debug logging.' });

  parser.addArgument([ '--secure' ],
    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',
      help: 'Serve secure websockets, requires --key-file and ' +
      '--cert-file if true, on by default.' });

  parser.addArgument([ '--start-rethinkdb' ],
    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',
      help: 'Start up a RethinkDB server in the current directory' });

  parser.addArgument([ '--auto-create-collection' ],
    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',
      help: 'Create collections used by requests if they do not exist.' });

  parser.addArgument([ '--auto-create-index' ],
    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',
      help: 'Create indexes used by requests if they do not exist.' });

  parser.addArgument([ '--permissions' ],
    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',
      help: 'Enables or disables checking permissions on requests.' });

  parser.addArgument([ '--serve-static' ],
    { type: 'string', metavar: 'PATH', nargs: '?', constant: './dist',
      help: 'Serve static files from a directory, defaults to "./dist".' });

  parser.addArgument([ '--dev' ],
    { action: 'storeTrue',
      help: 'Runs the server in development mode, this sets ' +
      '--secure=no, ' +
      '--permissions=no, ' +
      '--auto-create-collection=yes, ' +
      '--auto-create-index=yes, ' +
      '--start-rethinkdb=yes, ' +
      '--allow-unauthenticated=yes, ' +
      '--allow-anonymous=yes ' +
      'and --serve-static=./dist.' });

  parser.addArgument([ '--schema-file' ],
    { type: 'string', metavar: 'SCHEMA_FILE_PATH',
      help: 'Path to the schema file to use, ' +
      'will attempt to apply schema before starting Horizon server".' });

  parser.a ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.serve.processConfig" id="apidoc.element.horizon.serve.processConfig">
        function <span class="apidocSignatureSpan">horizon.serve.</span>processConfig
        <span class="apidocSignatureSpan">(parsed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(parsed) =&gt; {
  let options;

  options = config.default_options();

  options = config.merge_options(options,
    config.read_from_config_file(parsed.project_path));

  options = config.merge_options(options,
    config.read_from_secrets_file(parsed.project_path));

  options = config.merge_options(options, config.read_from_env());

  options = config.merge_options(options, config.read_from_flags(parsed));

  if (options.project_name === null) {
    options.project_name = path.basename(path.resolve(options.project_path));
  }

  if (options.bind.indexOf('all') !== -1) {
    options.bind = [ '0.0.0.0' ];
  }

  if (!options.rdb_host) {
    options.rdb_host = default_rdb_host;
  }

  if (!options.rdb_port) {
    options.rdb_port = default_rdb_port;
  }

  if (!options.rdb_timeout) {
    options.rdb_timeout = default_rdb_timeout;
  }

  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.horizon.serve.run" id="apidoc.element.horizon.serve.run">
        function <span class="apidocSignatureSpan">horizon.serve.</span>run
        <span class="apidocSignatureSpan">(args, interruptor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args, interruptor) =&gt; {
  let opts, http_servers, hz_server, rdb_server;
  const old_log_level = logger.level;

  const cleanup = () =&gt; {
    logger.level = old_log_level;

    return Promise.all([
      hz_server ? hz_server.close() : Promise.resolve(),
      rdb_server ? rdb_server.close() : Promise.resolve(),
      http_servers ? Promise.all(http_servers.map((s) =&gt;
        new Promise((resolve) =&gt; s.close(resolve)))) : Promise.resolve(),
    ]);
  };

  interrupt.on_interrupt(() =&gt; cleanup());

  return Promise.resolve().then(() =&gt; {
    opts = processConfig(parseArguments(args));
    logger.level = opts.debug ? 'debug' : 'warn';

    if (!opts.secure &amp;&amp; opts.auth &amp;&amp; Array.from(Object.keys(opts.auth)).length &gt; 0) {
      logger.warn('Authentication requires that the server be accessible via HTTPS. ' +
                  'Either specify "secure=true" or use a reverse proxy.');
    }

    change_to_project_dir(opts.project_path);

    if (opts.secure) {
      return create_secure_servers(opts);
    } else {
      return create_insecure_servers(opts);
    }
  }).then((servers) =&gt; {
    http_servers = servers;

    if (opts.start_rethinkdb) {
      return start_rdb_server().then((server) =&gt; {
        rdb_server = server;

        // Don't need to check for host, always localhost.
        opts.rdb_host = 'localhost';
        opts.rdb_port = server.driver_port;

        console.log('RethinkDB');
        console.log(`   â”œâ”€â”€ Admin interface: http://localhost:${server.http_port}`);
        console.log(`   â””â”€â”€ Drivers can connect to port ${server.driver_port}`);
      });
    }
  }).then(() =&gt; {
    // Ensure schema from schema.toml file is set
    if (opts.schema_file) {
      console.log(`Ensuring schema "${opts.schema_file}" is applied`);
      try {
        fs.accessAsync(opts.schema_file, fs.R_OK | fs.F_OK);
      } catch (e) {
        console.error(
          chalk.yellow.bold('No .hz/schema.toml file found'));
        return;
      }
      const schemaOptions = schema.processApplyConfig({
        project_name: opts.project_name,
        schema_file: opts.schema_file,
        start_rethinkdb: false,
        connect: `${opts.rdb_host}:${opts.rdb_port}`,
        update: true,
        force: false,
      });
      return schema.runApplyCommand(schemaOptions);
    }
  }).then(() =&gt; {
    console.log('Starting Horizon...');
    hz_server = start_horizon_server(http_servers, opts);

    return new Promise((resolve, reject) =&gt; {
      const timeoutObject = setTimeout(() =&gt; {
        reject(new Error('Horizon failed to start after 30 seconds.\n' +
                         'Try running hz serve again with the --debug flag'));
      }, TIMEOUT_30_SECONDS);

      hz_server.ready().then(() =&gt; {
        clearTimeout(timeoutObject);
        console.log(chalk.green.bold('ðŸŒ„ Horizon ready for connections'));
        resolve(hz_server);
      }).catch(reject);
    });
  }).then(() =&gt; {
    if (opts.auth) {
      for (const name in opts.auth) {
        const provider = horizon_server.auth[name];
        if (!provider) {
          throw new Error(`Unrecognized auth provider "${name}"`);
        }
        hz_server.add_auth_provider(provider,
                                    Object.assign({}, { path: name }, opts.auth[name]));
      }
    }
  }).then(() =&gt; {
    // Automatically open up index.html in the `dist` directory only if
    //  `--open` flag specified and an index.html exists in the directory.
    if (opts.open &amp;&amp; opts.serve_static) {
      try {
        // Check if index.html exists and readable in serve static_static directory
        fs.accessSync(`${opts.serve_static}/index.html`, fs.R_OK | fs.F_OK);
        // Determine scheme from options
        const scheme = opts.secure ? 'https://' : 'http://';
        // Open up index.html in default browser
        console.log('Attempting open of index.html in default browser');
        open(`${scheme}${opts.bind}:${opts.port}/index.html`);
      } catch (open_err) {
        console.log(chalk.red('Error occurred while trying to open ' +
                              `${opts.serve_sta ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&gt; {
    white('Validating current schema version');
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&gt; checkForHzTables)
      .do(() =&gt; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&gt; green(' â””â”€â”€ Pre-2.0 schema found'))
      .catch((e) =&gt; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don't have a Horizon app in this database, or if \
you've already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.horizon.version" id="apidoc.module.horizon.version">module horizon.version</a></h1>


    <h2>
        <a href="#apidoc.element.horizon.version.run" id="apidoc.element.horizon.version.run">
        function <span class="apidocSignatureSpan">horizon.version.</span>run
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(args) =&gt;
Promise.resolve().then(() =&gt; {
  if (args &amp;&amp; args.length) {
    throw new Error('create-cert takes no arguments');
  }
  console.info(package_json.version);
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.resolve().then(() =&gt; {
    white('Validating current schema version');
    return r.dbList().contains(`${project}_internal`)
      .branch(true, r.error(internalNotFound))
      .do(() =&gt; checkForHzTables)
      .do(() =&gt; waitForCollections)
      .<span class="apidocCodeKeywordSpan">run</span>(this.conn)
      .then(() =&gt; green(' â””â”€â”€ Pre-2.0 schema found'))
      .catch((e) =&gt; {
        if (e.msg === internalNotFound) {
          throw new NiceError(e.msg, {
            description: `\
This could happen if you don't have a Horizon app in this database, or if \
you've already migrated this database to the v2.0 format.`,
...</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>